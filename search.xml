<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[进程、线程、协程的区别和通信方式]]></title>
    <url>%2F2020%2F10%2F02%2F%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[进程进程，是操作系统资源分配（CPU时间片、内存空间）的最小单位。 进程通信：每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信。 进程间通信有4种方式，以下从简单到复杂的方式出场: 1.管道(pipe) 管道是一种具有两个端点的通信通道，一个管道实际上就是只存在在内存中的文件，对这个文件操作需要两个已经打开文件进行，他们代表管道的两端，也叫两个句槟，管道是一种特殊的文件，不属于一种文件系统，而是一种独立的文件系统，有自己的数据结构，根据管道的使用范围划分为无名管道和命名管道。无名管道用于父进程和子进程之间，通常父进程创建管道，然后由通信的子进程继承父进程的读端点句柄和写端点句柄，或者父进程有读写句柄的子进程，这些子进程可以使用管道直接通信，不需要通过父进程。命名管道，命名管道是为了解决无名管道只能在父子进程间通信而设计的，命名管道是建立在实际的磁盘介质或文件系统(而不是只存在内存中)，任何进程可以通过文件名或路径建立与该文件的联系，命名换到需要一种FIFO文件(有先进先出的原则)，虽然FIFO文件的inode节点在磁盘上，但仅是一个节点而已，文件的数据还是存在于内存缓冲页面中，和普通管道相同。 2.信号 信号，用于接受某种事件发生，除了用于进程间通信之外，进程还可以发送信号给进程本身。除了系统内核和root之外，只有具备相同id的进程才可以信号进行通信。 3.消息队列 消息队列是消息的链表，包括Posix消息队列和system v消息队列(Posix常用于线程，system常用于进程)，有权限的进程可以向消息队列中添加消息，有读权限的进程可以读走消息队列的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流及缓冲区大小受限等缺陷。 4.共享内存 共享内存使多个进程可以访问同一块内存空间，是最快的IPC形式，是针对其他通信方式运行效率低而设计的，往往与其他进程结合使用，如与信号量结合，来达到进程间的同步与互斥。传递文件最好用共享内存的方式。 linux常用的进程间的通讯方式（1）、管道(pipe)：管道可用于具有亲缘关系的进程间的通信，是一种半双工的方式，数据只能单向流动，允许一个进程和另一个与它有共同祖先的进程之间进行通信。（2）、命名管道(named pipe)：命名管道克服了管道没有名字的限制，同时除了具有管道的功能外（也是半双工），它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。（3）、信号（signal）：信号是比较复杂的通信方式，用于通知接收进程有某种事件发生了，除了进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。（4）、消息队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺（5）、共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。（6）、内存映射：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。（7）、信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。 （8）、套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。 线程线程是CPU调度、程序执行的最小单位。线程间通信主要通过等待/通知机制… 协程协程由程序自身控制子程序执行，有极高的执行效率，是比线程更轻量级的存在。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中接口和抽象类的分析]]></title>
    <url>%2F2020%2F10%2F01%2FJava%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[接口接口是抽象方法的集合，如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法 12345678910111213141516171819202122public interface MyInterface &#123; // 接口当中只能声明一些方法（隐式的抽象方法），但是不能有方法体 // 接口需要对应的实现类来实现具体方法 public void printName(String name); public String getNmae();&#125;public class MyInterfaceImpl implements MyInterface &#123; // 抽象类实现接口的时候，需要实现接口当中声明的所有方法 @Override public void printName(String name) &#123; System.out.println(name); &#125; @Override public String getNmae() &#123; return "name"; &#125;&#125; 抽象类抽象，顾名思义，就是具体的另一面。抽象类，主要是用来提炼子类的通用特性，是被用来创建具有继承关系的子类的模板。它本身不能被实例化，只能被用作子类的超类。需要实例化时必须重写抽象方法，变成一个具体类。 1234567891011121314151617181920212223242526272829303132public abstract class MyAbstractClass &#123; // 抽象类当中可以实现默认方法 public void printNum(int a) &#123; System.out.println(a); &#125; // 抽象方法只需要在抽象类当中声明，交由子类进行实现 abstract void service(String req, String res);&#125;// 继承抽象类的子类public class MySubAbstractClass extends MyAbstractClass &#123; public void doSomething() &#123; System.out.println("aaa"); &#125; @Override void service(String req, String res) &#123; // implementation &#125;&#125;public static void main(String[] args) &#123; MyAbstractClass m = new MyAbstractClass() &#123; @Override void service(String req, String res) &#123; // implementation &#125; &#125;;&#125; 抽象类和接口的对比 相关问题1、接口和抽象类有什么区别在Java语言中，抽象类abstract class和接口interface是抽象定义的两种机制。 正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。抽象类abstract class和接口interface在对于抽象定义方面具有很大的相似性，甚至可以相互替换。因此很多开发者在进行抽象定义时对二者的选择显得比较随意。其实，两者之间还是有很大的区别，对于它们的选择能反映出对问题本质的理解、对设计意图的理解。 具体如下： 2、interface应用在什么场合 类与类之间需要特定的接口进行协调，而不在乎其如何实现。 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。如序列化接口：Serializable 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。 想实现多重继承，由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口 3、abstract class应用在什么场合 子类与子类之间有共同的方法（甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖 重写），该方法写在抽象类中，避免每个子类再去写一遍；子类与子类之间不同的方法作为抽象方法，在抽象类中定义。 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的属性来区别不同的关系。 一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现，想提供默认实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》之虚拟机类加载机制]]></title>
    <url>%2F2020%2F10%2F01%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E4%B9%8B%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[类加载过程当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。 JVM虚拟机执行class字节码的过程可以分为7个阶段：加载、验证、准备、解析、初始化、使用、卸载 （没事多看书，多总结，多动手。） 1.加载：将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。 类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。 通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。 从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。 从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。 通过网络加载class文件。 把一个Java源文件动态编译，并执行加载。 类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。 2.链接 当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。 1)验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 四种验证做进一步说明： 文件格式验证：主要验证字节流是否符合Class文件格式规范，并且能被当前的虚拟机加载处理。例如：主，次版本号是否在当前虚拟机处理的范围之内。常量池中是否有不被支持的常量类型。指向常量的中的索引值是否存在不存在的常量或不符合类型的常量。 元数据验证：对字节码描述的信息进行语义的分析，分析是否符合java的语言语法的规范。 字节码验证：最重要的验证环节，分析数据流和控制，确定语义是合法的，符合逻辑的。主要的针对元数据验证后对方法体的验证。保证类方法在运行时不会有危害出现。 符号引用验证：主要是针对符号引用转换为直接引用的时候，是会延伸到第三解析阶段，主要去确定访问类型等涉及到引用的情况，主要是要保证引用一定会被访问到，不会出现类等无法访问的问题。 2)准备：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。 3)解析：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。 3.初始化 初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。 类加载机制：1.JVM的类加载机制主要有如下3种。 全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。 双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。 缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。 2.这里说明一下双亲委派机制： ​ 双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。 双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String类相关知识点]]></title>
    <url>%2F2020%2F08%2F14%2FString%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Java语言中String类是否可以被继承？在Java中String类的定义是 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;...&#125; 由此，可知String类是不可以被继承的，因为被final修饰的类是不可以被继承的 final关键字可以用来修饰类、成员变量、方法 修饰类被final修饰的类就不能被其他类继承了，设计类的时候如果不想这个类被其他类继承或者考虑一些安全因素，可以使用final修饰，否则尽量不要把类设计成final的。同时，类中所有的方法也被隐式的变为final方法。 修饰变量首先，变量分为基本数据类型和引用数据类型。被final修饰的基础类型和引用类型都是不能再次赋值的，这就说明被final修饰的变量是不可变的，相当于常量。因此，final修饰的变量必须被初始化，初始化可以在声明变量的时候，也可以在构造函数中初始化。 final修饰的变量和普通变量有什么区别 被final修饰的变量在使用的时候可以直接替换，因为其本身在编译期就可以确定下来是固定不可变的，对应值就会被放到字符串常量池中，而普通变量在编译阶段是一个变量，不能确定对应的值。 只有在编译阶段确定下来的字符串才会被放到字符串常量池中 修饰方法 final修饰的方法，不能被子类覆盖 仍然可以正常被调用 可以实现重载 static关键字定义静态常量 1static final String NAME = "hello java"; static表示唯一，独此一份，表示静态；final用来表示不可变 二者结合就是静态常量，全局唯一，同时与final不同，只被static修饰的变量，其值可以被修改。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现在是北京时间2020年5月16日早上7:37，我在杭州的家里早早起床]]></title>
    <url>%2F2020%2F05%2F16%2F2020-05-16%2F</url>
    <content type="text"><![CDATA[现在是北京时间2020年5月16日早上7:37，我在杭州的家里早早起床（大概不到6点就醒了），洗漱后出去买了早餐，这个时间要比平时出门上班早1个小时，难得的自由与清闲啊~~有木有？！昨天傍晚下了小雨，和同事们一起吃过饭后惊喜地发现雨停了，开心！所以出去走走都觉得好凉爽，好放松！ 我的工作是单休，所以今天也是工作日，不过初创小公司，注重结果大于形式，我们都在家办公还是比较人性化的。作为一名软件工程师，我深知自己还很菜，但是大家一起组成一个团队就很强了（所以更得投入精力成为团队的扛把子吖，小克同学听到木有？！），多人协作，直接沟通，交流碰撞的同时每个人的头脑都能活跃起来，思考并输出想法，最终达成共识从而形成有效的解决方案，朴素而务实的工程师文化大概不过如此吧~~ 最近负责的系统刚上线不久，一堆bug，一堆需求，痛并快乐着~~测试不到位，用例不足，完整的测试意识不强，后面要重视起来。不要什么事都那么独立地做，有些事一个人也不可能做到极致，要有意识地去找别人合作！ 本周碎碎念：要变得强大起来，要追求极致，要快乐而投入地工作，要有品质有感情的生活……要活得漂亮！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》之内存划分与溢出异常]]></title>
    <url>%2F2019%2F12%2F05%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[虚拟机内存管理JVM所管理的内存包括以下几个运行时数据区域： 不同虚拟机实现可能略微有所不同，但都会遵从 Java 虚拟机规范，Java 8 虚拟机规范规定，Java 虚拟机所管理的内存将会包括以下几个区域： 程序计数器（Program Counter Register） Java 虚拟机栈（Java Virtual Machine Stacks） 本地方法栈（Native Method Stack） Java 堆（Java Heap） 方法区（Methed Area） ① 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于 JVM 的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，也就是任何时刻，一个处理器（或者说一个内核）都只会执行一条线程中的指令。因此为了线程切换后能恢复到正确的执行位置，每个线程都有独立的程序计数器。 如果线程正在执行 Java 中的方法，程序计数器记录的就是正在执行虚拟机字节码指令的地址，如果是 Native 方法，这个计数器就为空（undefined），因此该内存区域是唯一一个在 Java 虚拟机规范中没有规定 OutOfMemoryError 的区域。 ② Java 虚拟机栈 Java 虚拟机栈（Java Virtual Machine Stacks）描述的是 Java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应着一个栈帧在虚拟机栈中入栈到出栈的过程。Java虚拟机规范中规定了2种异常状况： 如果线程请求的栈深度大于虚拟机所允许的栈深度就会抛出 StackOverflowError 异常。 如果虚拟机是可以动态扩展的，如果扩展时无法申请到足够的内存就会抛出 OutOfMemoryError 异常。 ③ 本地方法栈 本地方法栈（Native Method Stack）与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。 在 Java 虚拟机规范中对于本地方法栈没有特殊的要求，虚拟机可以自由的实现它，因此在 Sun HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一了。 ④ Java 堆 Java 堆（Java Heap）是 JVM 中内存最大的一块，是被所有线程共享的，在虚拟机启动时候创建，Java 堆唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化的技术将会导致一些微妙的变化，所有的对象都分配在堆上渐渐变得不那么绝对了。 如果在堆中没有内存完成实例分配，并且堆不可以再扩展时，将会抛出 OutOfMemoryError。 Java 虚拟机规范规定，Java 堆可以处在物理上不连续的内存空间中，只要逻辑上连续即可，就像我们的磁盘空间一样。在实现上也可以是固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是可扩展的，通过 -Xmx 和 -Xms 控制。 Java堆是GC收集器管理的主要区域。 ⑤ 方法区 方法区（Methed Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。 很多人把方法区称作“永久代”（Permanent Generation），本质上两者并不等价，只是 HotSpot 虚拟机垃圾回收器团队把 GC 分代收集扩展到了方法区，或者说是用来永久代来实现方法区而已，这样能省去专门为方法区编写内存管理的代码，但是在 JDK 8 也移除了“永久代”，使用 Native Memory 来实现方法区。 当方法无法满足内存分配需求时会抛出 OutOfMemoryError 异常。 相关问题：1.什么是 JVM？它有什么作用？答：JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，顾名思义它是一个虚拟计算机，也是 Java 程序能够实现跨平台的基础。它的作用是加载 Java 程序，把字节码翻译成机器码再交由 CPU 执行的一个虚拟计算器。 2.JVM 主要组成部分有哪些？答：JVM 主要组成部分如下： 类加载器（ClassLoader） 运行时数据区（Runtime Data Area） 执行引擎（Execution Engine） 本地库接口（Native Interface） 3.JVM 是如何工作的？答：首先程序在执行之前先要把 Java 代码（.java）转换成字节码（.class），JVM 通过类加载器（ClassLoader）把字节码加载到内存中，但字节码文件是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine） 将字节码翻译成底层机器码，再交由 CPU 去执行，CPU 执行的过程中需要调用本地库接口（Native Interface）来完成整个程序的运行。 4.变量存储？栈区存放函数的参数值，局部变量的值等；堆区存放的是程序员创建的对象；全局区存放全局变量和静态变量；常量区存放常量字符串 5.内存溢出和内存泄漏的区别是什么？答：内存溢出和内存泄漏的区别如下： 内存溢出是指程序申请内存时，没有足够的内存，就会报错 OutOfMemoryError； 内存泄漏是指垃圾对象无法回收，可以使用 Memory Analyzer 等工具排除内存泄漏。 对象的创建：使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Swap算法的收集器时，通常采用空闲列表 不同内存分区存放不同数据类型的不清晰的认识： Java内存：堆内存、栈内存、方法区 堆内存：基本数据类型，引用类型 栈内存：递归无终止条件会导致StackOverFlowError，栈空间的耗尽 方法区：函数，方法名]]></content>
      <tags>
        <tag>Java, JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》之GC]]></title>
    <url>%2F2019%2F12%2F05%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E4%B9%8BGC%2F</url>
    <content type="text"><![CDATA[内存动态分配和垃圾收集技术GC：哪些内存需要回收？什么时候回收？如何回收？ 当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对内存动态分配和垃圾收集技术实施必要的监控和调节。 垃圾收集器关注的是Java堆和方法区中的动态分配和回收的内存。 判断对象存活与否？ 1、引用计数算法：主流的Java虚拟机未采用，很难解决对象之间相互循环引用的问题 2、可达性分析算法：判定对象是否可回收 对象真正死亡：至少经历两次标记过程：finalize()最多执行一次 一、垃圾收集算法：1.标记-清除算法 Mark and Sweep分为标记和清除两个阶段，是最基础的收集算法，主要不足：1、效率问题；2、空间问题：标记清除之后会产生大量不连续的内存碎片，导致之后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次GC。 2.复制算法 Copying一块内存平均划分为2块，一块空闲，一块存储，当回收的时候，把另一半中仍然存活的复制过来，并将其内存全部收回——解决了效率问题（每次都是对半个区域进行内存回收，内存分配时也不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单运行高效）。比较适合“朝生夕死”的新生代对象。 Eden:Survivor0:Survivor = 8:1:1 3.标记-整理算法 Mark-Compact标记以后，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。适用于老年代，绝大多数对象都存活的情况。 4.分代收集算法一般将Java堆分为新生代和老年代，对于新生代，每次收集时都发现有大批对象死去，只有少量存活，就选用复制算法，只需付出少量复制成本即可完成回收。而老年代中对象存活率高，没有额外空间对其进行担保，就必须使用“标记清除”或者“标记整理”算法回收。 一般新生代触发内存回收称之为Yong GC，而老年代大对象触发内存回收称之为Full GC Young区（新生代），Elden区（老年代），Survivor区（永久代）：S0，S1，Meta Space，S0:S1=9:1 Java内存：堆内存、栈内存、方法区 堆内存：基本数据类型，引用类型，Java8之后常量池移动堆中 栈内存：递归无终止条件会导致StackOverFlowError，栈空间的耗尽 方法区：函数，方法名 二、垃圾回收器收集算法是内存回收的方法论，垃圾收集器是内存回收的具体实现。 7种作用于不同分代的收集器： 特性、基本原理和使用场景： 重点分析CMS和G1相对复杂的收集器，了解运作细节。 新生代：Serial、ParNew、Praralell Scavenge 老年代：CMS、Serial Old、Parallel Old、G1 1、Serial收集器单线程，stop the world，是虚拟机运行在Client模式下的默认新生代收集器，与其他收集器的单线程相比，简单而高效。对于限定单个CPU的环境而言，Serial由于没有线程交互的开销，可以获得最高的单线程收集效率。 新生代采取复制算法，而老年代采取标记-整理算法。 2、ParNew收集器是Serial的多线程版本，行为包括：Serial可用的所有控制参数、收集算法、stop the world、对象分配规则、回收策略。这两种收集器共用了不少代码。 -XX:ParallelGCThreads用来限制垃圾收集的线程数，ParNew收集器是使用-XX:+UseConcMarkSweepGC后的默认新生代收集器。可以使用-XX:+UseParNewGC强制使用。 3、Praralell Scavenge（清除）收集器复制算法，并行的多线程收集器，目标是达到可控制的吞吐量（吞吐量优先收集器），吞吐量=运行用户代码时间/(运行用户代码时间+GC时间)，低停顿时间有利于提高响应速度，因而适合交互较多的程序，高吞吐量可以高效利用CPU时间，尽快完成程序的运算任务，主要适合后台计算。 精确控制吞吐量的参数：-XX:MaxGCPauseMillis（控制最大GC停顿时间），-XX:GCTimeRatio（直接设置吞吐量大小） GC停顿时间缩短是以牺牲吞吐量和新生代空间为代价的。 自适应调节策略：-XX:+UseAdaptiveSizePolicy 开启GC自适应调节策略后，无需手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等参数，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 4、Serial Old收集器单线程、标记-整理算法、老年代，给Client模式的VM使用，Server模式下，作为CMS的后备预案（在并发收集发生Concurrent Mode failure时使用） 5、Parallel Old收集器是Praralell Scavenge的老年代版本，多线程，标记-整理算法，在注重吞吐量以及CPU资源敏感的场合，可以优先考虑使用Praralell Scavenge+Praralell Old组合。 相关问题：1.哪些对象可以作为引用链的 Root 对象？答：引用链的 Root 对象可以为以下内容： Java 虚拟机栈中的引用对象； 本地方法栈中 JNI（既一般说的 Native 方法）引用的对象； 方法区中类静态常量的引用对象； 方法区中常量的引用对象。 2.对象引用关系都有哪些？答：不管是引用计数法还是可达性分析算法都与对象的“引用”有关，这说明对象的引用决定了对象的生死，对象的引用关系如下。 强引用：在代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。 软引用：是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM 认为内存不足时，才会去试图回收软引用指向的对象，JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。 弱引用：非必需对象，但它的强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 虚引用：也称为幽灵引用或幻影引用，是最弱的一种引用关系，无法通过虚引用来获取一个对象实例，为对象设置虚引用的目的只有一个，就是当这个对象被收集器回收时收到一条系统通知。 3.垃圾回收算法有哪些？答：垃圾回收算法如下。 引用计数器算法：引用计算器判断对象是否存活的算法是这样的，给每一个对象设置一个引用计数器，每当有一个地方引用这个对象的时候，计数器就加 1，与之相反，每当引用失效的时候就减 1。 可达性分析算法：在主流的语言的主流实现中，比如 Java、C#，甚至是古老的 Lisp 都是使用的可达性分析算法来判断对象是否存活的。这个算法的核心思路就是通过一些列的“GC Roots”对象作为起始点，从这些对象开始往下搜索，搜索所经过的路径称之为“引用链”。当一个对象到 GC Roots 没有任何引用链相连的时候，证明此对象是可以被回收的。 复制算法：复制算法是将内存分为大小相同的两块，当这一块使用完了，就把当前存活的对象复制到另一块，然后一次性清空当前区块。此算法的缺点是只能利用一半的内存空间。 标记-清除算法：此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。 标记-整理：此算法结合了“标记-清除”和“复制”两个算法的优点。分为两个阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。 4.垃圾回收的分类都有哪些？答：垃圾回收的分类如下： 新生代回收器：Serial、ParNew、Parallel Scavenge 老年代回收器：Serial Old、Parallel Old、CMS 整堆回收器：G1 5.分代垃圾回收器的组成部分有哪些？答：分代垃圾回收器是由：新生代（Young Generation）和老生代（Tenured Generation）组成的，默认情况下新生代和老生代的内存比例是 1:2。 6.新生代的组成部分有哪些？答：新生代是由：Eden、Form Survivor、To Survivor 三个区域组成的，它们内存默认占比是 8:1:1。 7.新生代垃圾回收是怎么执行的？答：新生代垃圾回收的执行过程如下： ① Eden 区 + From Survivor 区存活着的对象复制到 To Survivor 区；② 清空 Eden 和 From Survivor 分区；③ From Survivor 和 To Survivor 分区交换（From 变 To，To 变 From）。 8.为什么新生代有两个 Survivor 分区？答：当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。 如果 Survivor 是 0 的话，也就是说新生代只有一个 Eden 分区，每次垃圾回收之后，存活的对象都会进入老生代，这样老生代的内存空间很快就被占满了，从而触发最耗时的 Full GC ，显然这样的收集器的效率是我们完全不能接受的。 如果 Survivor 分区是 1 个的话，假设把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低不是最佳的方案。但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作，显然这种垃圾回收器最大的问题就在于，需要频繁进行垃圾回收。 如果 Survivor 分区有 2 个分区，我们就可以把 Eden、From Survivor、To Survivor 分区内存比例设置为 8:1:1 ，那么任何时候新生代内存的利用率都 90% ，这样空间利用率基本是符合预期的。再者就是虚拟机的大部分对象都符合“朝生夕死”的特性，因此每次新对象的产生都在空间占比比较大的 Eden 区，垃圾回收之后再把存活的对象方法存入 Survivor 区，如果是 Survivor 区存活的对象，那么“年龄”就 +1 ，当年龄增长到 15 （可通过 -XX:+MaxTenuringThreshold 设定）对象就升级到老生代。 经过以上对比，可以得出结论，当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。 9.什么是 CMS 垃圾回收器？答：CMS（Concurrent Mark Sweep）一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。 10.CMS 垃圾回收器有哪些优缺点？答：CMS 垃圾回收器的优点是使用多线程，标记清除垃圾的，它缺点如下。 对 CPU 资源要求敏感：CMS 回收器过分依赖于多线程环境，默认情况下，开启的线程数为（CPU 的数量 + 3）/ 4，当 CPU 数量少于 4 个时，CMS 对用户本身的操作的影响将会很大，因为要分出一半的运算能力去执行回收器线程； CMS 无法清除浮动垃圾：浮动垃圾指的是 CMS 清除垃圾的时候，还有用户线程产生新的垃圾，这部分未被标记的垃圾叫做“浮动垃圾”，只能在下次 GC 的时候进行清除； CMS 垃圾回收会产生大量空间碎片：CMS 使用的是标记-清除算法，所有在垃圾回收的时候回产生大量的空间碎片。 11.什么是 G1 垃圾回收器？答：G1 垃圾回收器是一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS CG，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。 G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 Region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。 12.垃圾回收的调优参数有哪些？答：垃圾回收的常用调优如下： -Xmx:512 设置最大堆内存为 512 M； -Xms:215 初始堆内存为 215 M； -XX:MaxNewSize 设置最大年轻区内存； -XX:MaxTenuringThreshold=5 设置新生代对象经过 5 次 GC 晋升到老年代； -XX:PretrnureSizeThreshold 设置大对象的值，超过这个值的大对象直接进入老生代； -XX:NewRatio 设置分代垃圾回收器新生代和老生代内存占比； -XX:SurvivorRatio 设置新生代 Eden、Form Survivor、To Survivor 占比。]]></content>
      <tags>
        <tag>Java, JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》之Java内存模型]]></title>
    <url>%2F2019%2F12%2F03%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E4%B9%8BJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、内存模型1.分为主内存和工作内存，分别对应虚拟机内存的堆内存、栈内存、方法区 2.8大基本操作：lock-&gt;unlock, read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write 3.原子性、可见性、有序性 二、线程安全与高效并发：线程调度： 1.内核线程（KLT） 2.用户线程（UT） 3.用户线程（UT）与轻量级进程（LWP)的混合模式 高效并发： 多线程环境下，线程资源的安全调用： 先行发生原则：happens before原则： 并发编程三要素：要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 实现更大范围操作的原子性可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 Java提供了volatile关键字来保证可见性当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 java.util.concurrent.atomic包下提供了一些原子操作类，对基本数据类型的操作进行了封装，保证这些操作是原子性操作 CAS实现原子性操作Compare And Swap CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 Volatile保证可见性和禁止指令重排序 原理和实现机制下面这段话摘自《深入理解Java虚拟机》： “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令” lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能： 1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成； 2）它会强制将对缓存的修改操作立即写入主存； 3）如果是写操作，它会导致其他CPU中对应的缓存行无效。]]></content>
      <tags>
        <tag>Java, JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring事务传播机制]]></title>
    <url>%2F2019%2F10%2F24%2FSpring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Spring事务传播机制1、事务抽象，特性： ①REQUIRED：如果当前没有事务就需要创建一个新事务，否则就加入该事务，最常用也是Spring默认设置 12345678910 @Transactional(propagation = Propagation.REQUIRED)public void methodA() &#123; // 7种事务传播机制：默认都是REQUIRED methodB(); &#125; @Transactional(propagation = Propagation.REQUIRED)public void methodB() &#123; // do something &#125; 使用默认的事务传播机制，执行过程如下：调用A方法开启一个事务执行方法A的代码，紧接着执行方法B的代码，提交或者回滚事务（如果方法B出现了异常，则方法A最终回滚整体单个事务） ②SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，否则以非事务执行 12345678910@Transactional(propagation = Propagation.REQUIRED)public void methodA() &#123; // 7种事务传播机制：默认都是REQUIRED methodB();&#125;@Transactional(propagation = Propagation.SUPPORTS)public void methodB() &#123; // do something&#125; 直接调用方法B不会执行事务 ③MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，否则就强制抛出异常 12345678910@Transactional(propagation = Propagation.REQUIRED)public void methodA() &#123; // 7种事务传播机制：默认都是REQUIRED methodB();&#125;@Transactional(propagation = Propagation.SUPPORTS)public void methodB() &#123; // do something&#125; 直接调用方法B会报错 ④REQUIRES_NEW：创建新事务，无论是否存在事务，都创建新事务 12345678910@Transactional(propagation = Propagation.REQUIRED)public void methodA() &#123; // 7种事务传播机制：默认都是REQUIRED methodB();&#125;@Transactional(propagation = Propagation.REQUIRES_NEW)public void methodB() &#123; // do something&#125; 调用方法A会开启事务1，执行完A里面的代码后，开启事务2执行方法B里面的代码，提交或回滚事务2，最后提交或回滚事务1。事务1和事务2互不影响 ⑤NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，则把当前事务挂起（一般很少用到） ⑥NEVER：以非事务方式执行操作，如果当前存在事务，则抛出异常 ⑦NESTED：嵌套事务：外层的事务如果回滚，会导致内层的事务也回滚，但内层的事务如果回滚仅仅回滚自己的代码 相关思考：1.有一段业务逻辑，A调用B，如果A出错了仅仅回滚A，不能回滚B，这时必须得用REQUIRES_NEW传播机制，让A和B的事务是不同的两个事务 2.A调用B，如果出错，B只能回滚自己，而A可以带着B一起回滚，这时得用NESTED来嵌套事务 Tips: Spring事务隔离级别 Spring默认的是数据库存储引擎的事务隔离级别，mysql默认隔离级别为可重复读]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring设计模式]]></title>
    <url>%2F2019%2F10%2F23%2FSpring%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Spring设计模式工厂模式spring ioc的核心设计模式的思想体现，本身就是一个大的工厂，把所有的bean实例都放在了spring 容器里（大工厂），如果要使用bean就直接找spring容器就好了，自己不用创建对象。 123456789101112public class MyController &#123; // 原先每次都要自己new一个 private MyService mySerice = new MyService(); // 使用spring @Autowire注解自动注入一个，实际底层是依靠的工厂模式去创建的 private MyService mySerice = MyServiceFactory.getMyService();&#125;public class MyServiceFactory &#123; public static MyService getMyService() &#123; return new MyServiceImpl(); &#125;&#125; 单例模式spring默认对每个bean都走的单例模式，确保一个类在系统运行期间只有一个实例对象，只有一个bean 123456789101112131415public class MyService &#123; private static volatile Myservice myService; // 禁止指令重排序 public stativ MyService getInstance() &#123; if (myService == null) &#123; synchronized(MyService.class) &#123; if (myService == null) &#123; myService = new MyService(); &#125; &#125; &#125; return myService; &#125;&#125; 代理模式AOP的核心模式，如果要对一些类的方法切入一些增强的代码，会创建一些动态代理的对象，让你对那些目标对象的访问，先经过动态代理对象，动态代理对象先执行一些增强的代码，再调用你的目标对象。在设计模式里，就是代理模式的体现和运用，实现一些增强的访问。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码分析之Map]]></title>
    <url>%2F2019%2F10%2F09%2FJDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMap%2F</url>
    <content type="text"><![CDATA[java.util.Map Map 简介Map是java.util提供的一个接口，是存储键值对映射的容器。AbstractMap是由abstract修饰的Map的抽象实现。 Map 常用的实现类如下： Hashtable：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用。 HashMap：最常用的哈希表实现，如果程序中没有多线程的需求，HashMap 是一个很好的选择，支持 null 键和值，如果在多线程中可用 ConcurrentHashMap 替代。 TreeMap：基于红黑树的一种提供顺序访问的 Map，自身实现了 key 的自然排序，也可以指定 Comparator 来自定义排序。 LinkedHashMap：HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。 HashMap 数据结构HashMap 底层的数据是数组被称为哈希桶，每个桶存放的是链表，链表中的每个节点，就是 HashMap 中的每个元素。在 JDK 8 当链表长度大于等于 8 时，就会转成红黑树的数据结构，以提升查询和插入的效率。 HashMap结构：哈希数组+链表/红黑树，key和value均可以为null存储元素时，需要调用key的hashCode()方法，计算出一个哈希值1.哈希值相同的元素，必定位于同一个哈希槽（链）上，但不能确定这两个元素是不是同位元素在进一步判断key如果相等（必要时需要调用equals()方法）时，才能确定这两个元素属于同位元素如果是存储同位元素，需要考虑是否允许覆盖旧值的问题2.哈希值不同的元素，它们也可能位于同一个哈希槽（链）上，但它们肯定不是同位元素 ConcurrentHashMap结构：哈希数组+链表/红黑树，key和value均不能为null，ConcurrentHashMap的操作方式跟HashMap是基本统一的，不同之处在于，ConcurrentHashMap是线程安全的，其中用到了无锁编程（1.7是分段锁，1.8是CAS）。获取map.size，里面有一个final修饰的sumCount()方法，在基于CAS更新的baseCount基础上，不断遍历累加大小为2的幂的数组CounterCell（本质是一个分开计数的容器）中元素的value值。 HashMap 数据结构，如下图： 1.7和1.8之间的变化1.7之前是数组+链表，数组节点是一个Entry的内部类 问题： 1.数据插入使用了头插法，导致了resize扩容问题，resize调用了transfer方法，把里面的Node进行了一个rehash，这个过程可能会造成链表的循环，就可能在下一次get()的时候出现死循环的情况； 2.因为没有加锁，多线程运行时候，无法保证线程安全 1.8之后是数组+链表+红黑树，把原来的一个Entry节点改成了Node节点（静态内部类），整个put过程做了一个优化 扩容机制： capacity容量：HashMap初始化的时候，如果没有设置capacity，默认的容量是16，loadFactor是0.75，会计算出来一个扩容的阈值threshold。 判断当前map.size()是否&gt;阈值，如果大于会新创建一个2倍大小容量来将原来的size进行resize() ConcurrentHashMap集合容器，对比HashTable, Synchronized, Lock, Collection.Synchronized线程同步方式 并发度是更高的，HashTable是直接对内部的方法做了Synchronized，加了一把对象锁 ConcurrentHashMap只会锁住当前获取到的Entry所在节点的值，锁的粒度是更细的，并且在上锁的时候使用的是CAS+Synchronized，因此效率是更高的，并发度是更高的，并发支持更好。 JDK1.6之后对Synchronized的优化锁升级：无锁&gt;偏向锁&gt;自旋锁&gt;重量级锁 先判断是否需要加锁，不涉及并发处理就是无锁，其次需要锁的时候支持偏向锁，获取到资源的线程，会让它再次获取锁，如果没有获取到就升级成一个轻量级的锁，CAS的乐观锁；如果CAS没有设置成功它会进行一个自旋，自旋到一定的次数之后才会升级成一个Synchronized的重量级的锁。 hash算法优化123456 // JDK1.8源码参考static final int hash(Object key) &#123; int h; // 原哈希值与右移16位的值进行亦或运算 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 1111 1111 1111 1111 1010 1110 0011 1001 0000 0000 0000 0000 1111 1111 1111 1111 1111 1111 1111 1111 0101 0001 1100 0110 int类型，32位（4字节）长度 高低16位都参与运算，最终结果等价于保留高16位，低16位由高低16位亦或求得结果 相当于对低16位进行了转码处理，可以融合高低16位的特征，尽量避免后续的hash冲突 寻址算法优化(n-1) &amp; hash -&gt; 数组中的某个位置 直接用哈希值对数组长度取模，性能比较差，为了优化这个寻址过程，确保hash&amp;(n-1)和hash%n效果是一样的，但是与运算的性能要比hash对n取模高很多。 hash碰撞数组 + 链表， 遍历一遍是O(n)，链表很长的话，性能比较差。 优化：链表长度达到8之后，会把链表转换为红黑树，遍历红黑树查找某个元素时，需要O(logn)，性能比链表更高一些。 HashMap 重要方法1）添加方法：put(Object key, Object value)执行流程如下： 对 key 进行 hash 操作，计算存储 index； 判断是否有哈希碰撞，如果没碰撞直接放到哈希桶里，如果有碰撞则以链表的形式存储； 判断已有元素的类型，决定是追加树还是追加链表，当链表大于等于 8 时，把链表转换成红黑树； 如果节点已经存在就替换旧值； 判断是否超过阀值，如果超过就要扩容。 put() 执行流程图如下： 2）获取方法：get(Object key)执行流程如下： 首先比对首节点，如果首节点的 hash 值和 key 的 hash 值相同，并且首节点的键对象和 key 相同（地址相同或 equals 相等），则返回该节点； 如果首节点比对不相同、那么看看是否存在下一个节点，如果存在的话，可以继续比对，如果不存在就意味着 key 没有匹配的键值对。 相关问题1.Map 常见实现类有哪些？答：Map 的常见实现类如下列表： Hashtable：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用； HashMap：最常用的哈希表实现，如果程序中没有多线程的需求，HashMap 是一个很好的选择，支持 null 键和值，如果在多线程中可用 ConcurrentHashMap 替代； TreeMap：基于红黑树的一种提供顺序访问的 Map，自身实现了 key 的自然排序，也可以指定的 Comparator 来自定义排序； LinkedHashMap：HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。 2.使用 HashMap 可能会遇到什么问题？如何避免？答：HashMap 在并发场景中可能出现死循环的问题，这是因为 HashMap 在扩容的时候会对链表进行一次倒序处理，假设两个线程同时执行扩容操作，第一个线程正在执行 B→A 的时候，第二个线程又执行了 A→B ，这个时候就会出现 B→A→B 的问题，造成死循环。解决的方法：升级 JDK 版本，在 JDK 8 之后扩容不会再进行倒序，因此死循环的问题得到了极大的改善，但这不是终极的方案，因为 HashMap 本来就不是用在多线程版本下的，如果是多线程可使用 ConcurrentHashMap 替代 HashMap。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码分析之Collection]]></title>
    <url>%2F2019%2F10%2F08%2FJDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BCollection%2F</url>
    <content type="text"><![CDATA[集合的继承关系图中，看出集合的根节点是 Collection，而 Collection 下又提供了两大常用集合，分别是： List：使用最多的有序集合，提供方便的新增、修改、删除的操作； Set：集合不允许有重复的元素，在许多需要保证元素唯一性的场景中使用。 集合使用： 1）VectorVector 是 Java 早期提供的线程安全的有序集合，实现了同步但是效率低已经不用了，如果不需要线程安全，不建议使用此集合，毕竟同步是有线程开销的。Stack继承了Vector 使用示例代码： 12345Vector vector = new Vector();vector.add("dog");vector.add("cat");vector.remove("cat");System.out.println(vector); 程序执行结果：[dog] 2）ArrayListArrayList 是最常见的非线程安全的有序集合，因为内部是数组存储的，所以随机访问效率很高，但非尾部的插入和删除性能较低，如果在中间插入元素，之后的所有元素都要后移。ArrayList 的使用与 Vector 类似。 3）LinkedListLinkedList 是使用双向链表数据结构实现的，因此增加和删除效率比较高，而随机访问效率较差。 LinkedList是个双向链表，它同样可以被当作栈、队列或双端队列来使用 LinkedList 除了包含以上两个类的操作方法之外，还新增了几个操作方法，如 offer() 、peek() 等，具体详情，请参考以下代码： 12345678910LinkedList linkedList = new LinkedList();// 添加元素linkedList.offer("bird");linkedList.push("cat");linkedList.push("dog");// 获取第一个元素System.out.println(linkedList.peek());// 获取第一个元素，并删除此元素System.out.println(linkedList.poll());System.out.println(linkedList); 程序的执行结果： 123dogdog[cat, bird] 4）HashSetHashSet 是一个没有重复元素的集合。虽然它是 Set 集合的子类，实际却为 HashMap 的实例，相关源码如下： 123public HashSet() &#123; map = new HashMap&lt;&gt;();&#125; 因此 HashSet 是无序集合，没有办法保证元素的顺序性。 HashSet 默认容量为 16，每次扩充 0.75 倍，相关源码如下： 1234public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125; HashSet 的使用与 Vector 类似。 5）TreeSetTreeSet 集合实现了自动排序，也就是说 TreeSet 会把你插入数据进行自动排序。 示例代码如下： 123456TreeSet treeSet = new TreeSet();treeSet.add(&quot;dog&quot;);treeSet.add(&quot;camel&quot;);treeSet.add(&quot;cat&quot;);treeSet.add(&quot;ant&quot;);System.out.println(treeSet); 程序执行结果：[ant, camel, cat, dog] 可以看出，TreeSet 的使用与 Vector 类似，只是实现了自动排序。 6）LinkedHashSetLinkedHashSet 是按照元素的 hashCode 值来决定元素的存储位置，但同时又使用链表来维护元素的次序，这样使得它看起来像是按照插入顺序保存的。 相关问题1.List 和 Set 有什么区别？ List 允许有多个 null 值，Set 只允许有一个 null 值； List 允许有重复元素，Set 不允许有重复元素； List 可以保证每个元素的存储顺序，Set 无法保证元素的存储顺序。 2.Collection 和 Collections 有什么区别？答：Collection 和 Collections 的区别如下： Collection 是集合类的上级接口，继承它的主要有 List 和 Set； Collections 是针对集合类的一个帮助类，它提供了一些列的静态方法实现，如 Collections.sort() 排序、Collections.reverse() 逆序等。 3.LinkedHashSet 如何保证有序和唯一性？答：LinkedHashSet 底层数据结构由哈希表和链表组成，链表保证了元素的有序即存储和取出一致，哈希表保证了元素的唯一性。 4.HashSet 是如何保证数据不可重复的？答：HashSet 的底层其实就是 HashMap，只不过 HashSet 实现了 Set 接口并且把数据作为 K 值，而 V 值一直使用一个相同的虚值来保存，我们可以看到源码： 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;// 调用 HashMap 的 put 方法,PRESENT 是一个至始至终都相同的虚值&#125; 由于 HashMap 的 K 值本身就不允许重复，并且在 HashMap 中如果 K/V 相同时，会用新的 V 覆盖掉旧的 V，然后返回旧的 V，那么在 HashSet 中执行这一句话始终会返回一个 false，导致插入失败，这样就保证了数据的不可重复性。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring容器的启动过程及生命周期]]></title>
    <url>%2F2019%2F10%2F08%2FSpring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E5%8F%8A%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[Spring容器的启动过程及生命周期Spring Container启动过程 创建和配置实例 刷新实例 Spring容器的启动全流程Spring容器的启动流程如下，这是我在看源码过程中自己总结的流程图，如有错误，还望评论区指点： 接下来附上源码： 为什么是refresh方法命名，而不是init命名呢？ 其实，在ApplicaitonContext建立起来之后，可以通过refresh进行重建，将原来的ac销毁，重新执行一次初始化操作，用refresh更加贴切。 Bean的创建和销毁 doGetBean全流程 createBean doCreateBean createBeanInstance 创建实例 populateBean 填充属性 initializeBean 回调方法 循环依赖N个类循环(嵌套)引，即N个Bean互相引用对方，最终形成闭环，表示对象之间的相互依赖关系 如果在日常开发中我们用new对象的方式，若构造函数之间发生这种循环依赖的话，程序会在运行时一直循环调用最终导致内存溢出，StackOverflowError 1234567891011public class A &#123; public A() &#123; B b = new B(); &#125;&#125;public class B &#123; public B() &#123; A a = new A(); &#125;&#125; 无法解决构造器/构造方法的循环依赖，因为一开始就实例化了，初始化 参考文章 https://cloud.tencent.com/developer/article/1497692 对于Spring解决循环依赖的认识 // 循环依赖：调用某实例对象的方法时，方法内部又涉及到另一个类的实例化，而B当中又依赖了A，所以这时先返回一个半成品的B，等A完成了实例化之后，再返回B的实例化，最终初始化 1、构造器注入循环依赖12345678910@Servicepublic class A &#123; public A(B b) &#123; &#125;&#125;@Servicepublic class B &#123; public B(A a) &#123; &#125;&#125; 结果：项目启动失败抛出异常BeanCurrentlyInCreationException 构造器注入构成的循环依赖，此种循环依赖方式是无法解决的，只能抛出BeanCurrentlyInCreationException异常表示循环依赖。这也是构造器注入的最大劣势 根本原因：Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是已经实例化，但还没初始化的状态。而构造器是完成实例化的东东（不存在中间态），所以构造器的循环依赖无法解决 2、field属性注入（setter方法注入）循环依赖这种方式是我们最最最最为常用的依赖注入方式（所以猜都能猜到它肯定不会有问题啦）： 1234567891011@Servicepublic class A &#123; @Autowired private B b;&#125;@Servicepublic class B &#123; @Autowired private A a;&#125; 结果：项目启动成功，能够正常work 3、prototype field属性注入循环依赖prototype在平时使用情况较少，但是也并不是不会使用到，因此此种方式也需要引起重视。 12345678910111213@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)@Servicepublic class A &#123; @Autowired private B b;&#125;@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)@Servicepublic class B &#123; @Autowired private A a;&#125; 结果：需要注意的是本例中启动时是不会报错的（因为非单例Bean默认不会初始化，而是使用时才会初始化），所以很简单咱们只需要手动getBean()或者在一个单例Bean内@Autowired一下它即可 123// 在单例Bean内注入 @Autowired private A a; 这样子启动就报错： 12345org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'mytest.TestSpringBean': Unsatisfied dependency expressed through field 'a'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'a': Unsatisfied dependency expressed through field 'b'; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'b': Unsatisfied dependency expressed through field 'a'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference? at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:596) at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:90) at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.postProcessProperties(AutowiredAnnotationBeanPostProcessor.java:374) 如何解决？？？ 可能有的小伙伴看到网上有说使用@Lazy注解解决： 123@Lazy@Autowiredprivate A a; 此处负责任的告诉你这样是解决不了问题的(可能会掩盖问题)，@Lazy只是延迟初始化而已，当你真正使用到它（初始化）的时候，依旧会报如上异常。 对于Spring循环依赖的情况总结如下： 不能解决的情况： 1. 构造器注入循环依赖 2. prototype field属性注入循环依赖 能解决的情况： 1. field属性注入（setter方法注入）循环依赖 Spring解决循环依赖的原理分析Spring的循环依赖的理论依据基于Java的引用传递，当获得对象的引用时，对象的属性是可以延后设置的。（但是构造器必须是在获取引用之前，毕竟你的引用是靠构造器给你生成的，儿子能先于爹出生？哈哈） Spring创建Bean的流程首先需要了解是Spring它创建Bean的流程，我把它的大致调用栈绘图如下： 对Bean的创建最为核心三个方法解释如下： createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象 populateBean：填充属性，这一步主要是对bean的依赖属性进行注入(@Autowired) initializeBean：回到一些形如initMethod、InitializingBean等方法 从对单例Bean的初始化可以看出，循环依赖主要发生在第二步（populateBean），也就是field属性注入的处理。 Spring容器的&#39;三级缓存&#39;在Spring容器的整个声明周期中，单例Bean有且仅有一个对象。这很容易让人想到可以用缓存来加速访问。 从源码中也可以看出Spring大量运用了Cache的手段，在循环依赖问题的解决过程中甚至不惜使用了“三级缓存”，这也便是它设计的精妙之处~ 三级缓存其实它更像是Spring容器工厂的内的术语，采用三级缓存模式来解决循环依赖问题，这三级缓存分别指： 123456789101112131415161718public class DefaultSingletonBeanRegistry extends SimpleAliasRegistry implements SingletonBeanRegistry &#123; ... // 从上至下 分表代表这“三级缓存” private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256); //一级缓存 private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;&gt;(16); // 二级缓存 private final Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = new HashMap&lt;&gt;(16); // 三级缓存 ... /** Names of beans that are currently in creation. */ // 这个缓存也十分重要：它表示bean创建过程中都会在里面呆着~ // 它在Bean开始创建时放值，创建完成时会将其移出~ private final Set&lt;String&gt; singletonsCurrentlyInCreation = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(16)); /** Names of beans that have already been created at least once. */ // 当这个Bean被创建完成后，会标记为这个 注意：这里是set集合 不会重复 // 至少被创建了一次的 都会放进这里~~~~ private final Set&lt;String&gt; alreadyCreated = Collections.newSetFromMap(new ConcurrentHashMap&lt;&gt;(256));&#125; 注：AbstractBeanFactory继承自DefaultSingletonBeanRegistry~ singletonObjects：用于存放完全初始化好的 bean，从该缓存中取出的 bean 可以直接使用 earlySingletonObjects：提前曝光的单例对象的cache，存放原始的 bean 对象（尚未填充属性），用于解决循环依赖 singletonFactories：单例对象工厂的cache，存放 bean 工厂对象，用于解决循环依赖]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea快捷键使用整理]]></title>
    <url>%2F2019%2F07%2F23%2Fidea%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、格式化编辑代码 Ctrl+Alt+L 2、sout 快速打印 一键格式化代碼： Ctrl+Alt+L 全局搜索替换：ctrl+shift+r 强大的搜索功能，shift+shift (无论您想要搜啥都能找到) ctrl+shift+R==搜索类 CTRL+N：按照类名搜索类 【常规】 Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 Ctrl+[ OR ]，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件 Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 - 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处 Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+”+/-“，当前方法展开、折叠 Ctrl+Shift+”+/-“，全部展开、折叠 【调试部分、编译】 Ctrl+F2，停止 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F10，运行 Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Ctrl+F8，切换行断点 Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构 Ctrl+Shift+C，复制路径 Ctrl+Alt+Shift+C，复制引用，必须选择类名 Ctrl+Alt+Y，同步 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局 Ctrl+Shift+F12，隐藏/恢复所有窗口 Ctrl+F4，关闭 Ctrl+Shift+F4，关闭活动选项卡 Ctrl+Tab，转到下一个拆分器 Ctrl+Shift+Tab，转到上一个拆分器 【重构】 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 【查找】 Ctrl+F，查找 Ctrl+R，替换 F3，查找下一个 Shift+F3，查找上一个 Ctrl+Shift+F，在路径中查找 Ctrl+Shift+R，在路径中替换 Ctrl+Shift+S，搜索结构 Ctrl+Shift+M，替换结构 Alt+F7，查找用法 Ctrl+Alt+F7，显示用法 Ctrl+F7，在文件中查找用法 Ctrl+Shift+F7，在文件中高亮显示用法 【VCS】 Alt+~，VCS 操作菜单 Ctrl+K，提交更改 Ctrl+T，更新项目 Ctrl+Alt+Shift+D，显示变化 以上皆由网络整理，不作商业用途，与本人无关]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue前端开发环境]]></title>
    <url>%2F2019%2F07%2F20%2FVue%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[技术 版本 说明 node v10.16.0 node编译环境 npm 6.9.0 npm包管理工具 Vue 2.9.6 前端框架 Vue-router 3.0.2 前端路由框架 Vuex 3.1.0 vue状态管理组件 Vue-cli ———— Vue脚手架 Element-ui 2.7.0 前端UI框架 Echarts 4.2.1 数据可视化框架 Uni-app ———— 跨平台前端框架 Mockjs 1.0.1-beta3 模拟后端数据 Axios 0.18.0 基于Promise的Http库 Js-cookie 2.2.0 Cookie组件 Jsonlint 1.6.3 Json解析组件 screenfull 4.2.0 全屏组件 Xlsx 0.14.1 Excel表导出组件 Webpack ———— 模板打包器 123456789101112131415# 安装vue$ npm install vue@2.1.6# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 webpack 模板的新项目my-project$ vue init webpack my-project# 进入项目目录$ cd my-project# 安装依赖$ npm install# 运行项目$ npm run dev# 卸载旧版本，在安装新版本。npm uninstall vue-cli -g npm install --global vue-cli]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务组件清单]]></title>
    <url>%2F2019%2F07%2F14%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[技术 版本 说明 Spring Cloud Netflix Finchley.RELEASE 分布式全家桶 Spring Cloud Eureka 2.0.0.RELEASE 服务注册 Spring Cloud Zipkin 2.0.0.RELEASE 服务链路 Spring Cloud config 2.0.0.RELEASE 服务配置 Spring Cloud Feign 2.0.0.RELEASE 服务调用 Spring Cloud Zuul 2.0.0.RELEASE 服务网关 Spring Cloud Hystrix 2.0.0.RELEASE 服务熔断 Spring Cloud Turbine 2.0.0.RELEASE 服务熔断监控 Spring Boot Admin 2.0.1 服务监控 Spring Boot 2.0.3.RELEASE 容器+MVC框架 Spring Security 5.1.4.RELEASE 认证和授权框架 MyBatis 3.4.6 ORM框架 MyBatisGenerator 1.3.3 数据层代码生成 PageHelper 5.1.8 MyBatis物理分页插件 Maven 3.6.1 项目管理工具 Swagger2 2.7.0 交互式API文档 Elasticsearch 6.2.2 搜索引擎 kibana 6.2.2 数据分析和可视化平台 LogStash 6.2.2 数据采集引擎 RabbitMq 3.7.14 消息队列 Redis 3.2 缓存 Druid 1.1.10 数据库连接池 OSS 2.5.0 对象存储 JWT 0.9.1 跨域身份验证解决方案 Lombok 1.18.6 简化对象封装工具 Junit 4.12 单元测试框架 Logback 1.2.3 日志框架 Java doc ———— API帮助文档 Docker 18.09.6 应用容器引擎 Docker-compose 18.09.6 容器快速编排]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring IOC和AOP]]></title>
    <url>%2F2019%2F07%2F13%2FSpring%20IOC%E5%92%8CAOP%2F</url>
    <content type="text"><![CDATA[一、SpringSpring的核心是IoC/DI的容器，它可以帮程序员完成组件之间的依赖关系注入，使得组件之间的依赖达到最小，进而提高组件的重用性，Spring是个低侵入性（invasive）的框架，Spring中的组件并不会意识到它正置身于Spring中，这使得组件可以轻易的从框架中脱离，而几乎不用任何修改，反过来说，组件也可以简单的方式加入至框架中，使得组件甚至框架的整合变得容易。 Spring最为人重视的另一方面是支持AOP（Aspect-Oriented Programming），然而AOP框架只是Spring支持的一个子框架，说Spring框架是AOP框架并不是一件适当的描述，人们对于新奇的 AOP关注映射至Spring上，使得人们对于Spring的关注集中在它的AOP框架上，虽然有所误解，但也突显了Spring的另一个令人关注的特色。 Spring是一个开源框架，是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。 （1）通过控制反转（IOC）达到松耦合，IOC也就是把控制权交出去，在使用中直接得到对象 （2）提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发（例如，商品的入库和出库是业务逻辑，而商品的入库和出库需要统一的日志记录和事务的管理是系统服务，与具体的业务无关，也就是无论业务如何，都要用到系统服务） （3）包含并管理应用对象的配置和生命周期，也就是容器的作用 （4）将简单的组件配置、组合成为复杂的应用，也就是框架的作用 框架与类库的区别： 框架一般是封装了逻辑、高内聚的，类库则是松散的工具组合 框架专注于某一领域，类库则是更通用的 Spring是一系列轻量级Java EE框架的集合：核心容器，Spring上下文，Spring AOP, Spring DAO, Spring ORM, Spring Web, Spring MVC。 IOC：控制反转，控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护，也就是不显示的进行new创建对象 DI（依赖注入）：是控制反转的一种实现方式，由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。也就是获得依赖对象的过程由自身管理变为由IOC容器主动注入。通过反射机制实现。 控制反转：控制反转的目的：创建对象并组装对象之间的关系。 IOC容器初始化时创建一系列对象，并把对象之间的依赖关系通过注入的方式组织起来，当一个类A中有另外一个B，实例化时，先实例化A这个对象，再实例化B这个对象，然后把B这个对象赋值给A，这就是IOC的组装对象，具体如下图 图解：业务对象进入Spring容器，然后通过配置的元数据，生产出符合我们需要的对象，当我们需要用的时候，直接从Spring容器中取出来用即可，这也就是IOC，应用程序只关心对象的使用，而不关心对象的创建 在IOC容器中，把所有对象称为Bean，Spring利用Bean来管理这些对象，Spring对于Bean和其他的使用有两种方式，一种是基于xml的配置，一种是注解方式。 依赖注入：借鉴http://blog.csdn.net/zhoudaxia/article/details/31763677 控制反转：把传统上由程序代码直接操控的对象的调用权交给外部容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”就是组件对象的控制权转移了，从程序代码本身转移到了外部容器。 实现控制反转的两种方式：依赖注入和依赖查找。 依赖注入有四种实现方式： 1.基于接口：实现特定接口以供外部容器注入所依赖类型的对象，接口中定义要注入依赖对象的方法。 2.基于setter方法：实现特定属性的public set方法，来让外部容器调用，以传入所依赖类型的对象。 3.基于构造函数：实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。 4.基于注解：基于Java的注解功能，在私有变量前加“@Autowired”等注解，不需要显式的定义以上三种代码，便可以让外部容器传入对应的对象。该方案相当于定义了public 的set方法，但是因为没有真正的set方法，从而不会为了实现依赖注入导致暴露了不该暴露的接口（因为set方法只想让容器访问来注入而不希望其他依赖此类的对象访问）。 AOP面向切面编程，]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术001]]></title>
    <url>%2F2018%2F08%2F02%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF001%2F</url>
    <content type="text"><![CDATA[Java八大基本类型8种基本数据类型，其中4种整型，2种浮点类型，1种用于表示Unicode编码的字符单元的字符类型和1种用于表示真值的boolean类型。 int / short / long / byte / float / double / char / boolean 1字节=8位，即1byte = 8bit，有符号整数，取值范围要先去掉符号位再计算数值大小 整型 类型 存储需求 bit数 取值范围 int 4 byte 32 -2^31 ~ 2^31-1（有符号整数） short 2 byte 16 -2^15 ~ 2^15-1 long 8 byte 64 byte 1 byte 8 －128～127 浮点型 类型 存储 bit 备注 float 4 byte 32 float类型的数值有一个后缀F(例如：3.14F) double 8 byte 64 没有后缀F的浮点数值(如3.14)默认为double类型 char类型 类型 存储 bit 备注 char 2 byte 16 boolean类型 类型 存储 bit 取值范围 boolean 1 byte 8 false、true Java有一个能够表示任意精度的数学包，通常称为“大数值”(big number)。虽然被称为大数值，但它并不是一种Java类型，而是一个Java对象。如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类：BigInteger，BigDecimal。这两个类可以处理包含任意长度数字序列的数值。BigInteger类实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。具体的用法可以参见Java API。 类型转换long转int12long a = 100L;int b = (int)a; 反射原理JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的以及动态调用对象的方法的功能称为Java的反射机制。 Java学习之反射机制及应用场景 - 对你说早安 - 博客园https://www.cnblogs.com/lzfsuifeng/p/9590705.html 反射机制提供了哪些功能？ 在运行时判定任意一个对象所属的类 在运行时判定任意一个类所具有的成员变量和方法； 在运行时构造任意一个类的对象； 在运行时调用任意一个对象的方法； 生成动态代理； 应用场景Java运行时的原理？ 动态代理 逆向代码 ，例如反编译 与注解相结合的框架 例如Retrofit 单纯的反射机制应用框架 例如EventBus 2.x 动态生成类框架 例如Gson 反射机制的优缺点： 优点： 运行期类型的判断，动态类加载，动态代理使用反射。 缺点： 性能是一个问题，反射相当于一系列解释操作，通知jvm要做的事情，性能比直接的java代码要慢很多。 Java中的静态变量和静态代码块是在类加载的时候就执行的，实例化对象时，先声明并实例化变量再执行构造函数。如果子类继承父类，则先执行父类的静态变量和静态代码块，再执行子类的静态变量和静态代码块。同样，接着在执行父类和子类非静态代码块和构造函数。 注意：（静态）变量和（静态）代码块的也是有执行顺序的，与代码书写的顺序一致。在（静态）代码块中可以使用（静态）变量，但是被使用的（静态）变量必须在（静态）代码块前面声明。 最后给出执行步骤： 1、父类静态变量和静态代码块（先声明的先执行）； 2、子类静态变量和静态代码块（先声明的先执行）； 3、父类的变量和代码块（先声明的先执行）； 4、父类的构造函数； 5、子类的变量和代码块（先声明的先执行）； 6、子类的构造函数。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux服务端开发环境部署及管理（一）]]></title>
    <url>%2F2018%2F04%2F28%2FLinux%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%8F%8A%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Linux服务端开发环境部署及管理（一）Centos7.2 x64环境下Java JDK、MySQL、Tomcat环境的搭建（基于腾讯云平台）腾讯云是个好东西，对于Linux平台不是很熟悉的人而言，开始学习时候很方便，提供各种方便的在线管理方式，如重装系统等。由于版本升级和系统兼容问题，开发中遇到的问题都很琐碎，大概是码农的日常了吧。 官网下载JDK以后，上传至Linux下，安装并设置环境变量。 java -version javac MySQL安装，由于MariaDB的出现，经常会出现系统兼容问题，据说在Centos7.0以后的版本中MySQL都不太兼容，所以需要特别注意。 首先，需要先卸载系统预装的MariaDB，然后下载安装MySQL 在Linux环境下，基本都是命令行操作，所以为了方便起见，建议学习过程中多多动手，多多总结。 Tomcat，类似，安装完后，需要设置环境变量。 启动Tomcat后，可以通过访问外网IP:端口号的方式检验是否安装成功。]]></content>
  </entry>
  <entry>
    <title><![CDATA[完美世界2018春招编程题]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C2018%E6%98%A5%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述：输入若干整数，以空格间隔，要求反转字符序列并打印输出。如： Input: 12 3 456 6789 Output: 6789 456 2 12 源代码：方法一、使用栈存储 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int a[20]; int i = 0; string ss, st; stack&lt;string&gt; s1; char c; do&#123; c = getchar(); if(c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;)&#123; ss += c; &#125;else if(c == &apos; &apos; || c == &apos;\n&apos;)&#123; s1.push(ss); ss = &quot;&quot;; &#125; &#125;while(c != &apos;\n&apos;); while(!s1.empty())&#123; st = s1.top(); s1.pop(); cout &lt;&lt; st; if(!s1.empty())&#123; cout &lt;&lt; &quot; &quot;; &#125;else&#123; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 方法一、使用数组变换存储 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt; using namespace std;int main()&#123; int a[20]; int i = 0; char c; string str = &quot;&quot;; do&#123; c=getchar(); if(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)&#123; str += c; &#125;else if(c ==&apos; &apos; || c == &apos;\n&apos;) &#123; a[i++] = atoi(str.c_str()); //atoi：将字符串转化为char*对象，再转换成一个整数值 str = &quot;&quot;; &#125; &#125;while(c!=&apos;\n&apos;); for(int j = 0; j &lt; i; j++)&#123; cout &lt;&lt; a[i-j-1]; if(i-j-1 != 0)&#123; cout &lt;&lt; &quot; &quot;; &#125;else&#123; cout &lt;&lt; endl; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[构建你的深度学习环境（一）]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[环境：Centos 7.2，python 2.7.5 1.首先安装好Linux 2.呼出命令行CTRL+ALT+T 3.检测是否安装python，一般Linux默认安装python 直接在命令行输入:python，会显示python的版本号，python2.7.9以上版本默认安装pip。可以看到我的版本号是2.7.5，否则进行步骤 4.eixt()退出python环境。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vuforia开发入门一准备工作]]></title>
    <url>%2F2018%2F04%2F03%2FVuforia%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%80%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Vuforia开发入门1、开发环境配置 a) Android 环境配置 b) Unity3D 下载和安装 2、资源下载 a) 官网注册 b) Samples资源下载]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>AR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视觉领域的部分国内公司]]></title>
    <url>%2F2018%2F03%2F09%2F%E8%A7%86%E8%A7%89%E9%A2%86%E5%9F%9F%E7%9A%84%E9%83%A8%E5%88%86%E5%9B%BD%E5%86%85%E5%85%AC%E5%8F%B8%2F</url>
    <content type="text"><![CDATA[##初创公司 图普科技Face++LinkfaceMinieye知图Cogtu商汤科技Sensetime亮风台Hiscene掌赢科技格灵深瞳DeepPG 凌感科技usens图森TuSimple中科视拓Seetatech(山世光)第四范式 ##上市公司： 百度DL实验室腾讯优图阿里高德暴风魔镜搜狗乐视tv奇虎360京东实验室阿里巴巴联想研究院华为研究院 ##知名外企： 佳能信息索尼研究院富士通研发中心微软研究院英特尔研究院三星研究院]]></content>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub博客管理命令汇总]]></title>
    <url>%2F2018%2F03%2F06%2FHexo-GitHub%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[[Hexo]部署博客及更新博文新建博文使用 Git Shell 进入本地 Blog 文件夹，输入以下命令： hexo n &quot;文章题目&quot; 命令执行完后，就会发现在Blog/source/_posts目录中多了一个文件 博文名.md，这就是我们刚才新建的博文。 新建页面上面新建的博文是显示在单个文章界面，这里新建的页面是作为单个页面显示的，比如分类、标签、归档和关于我，你点击后都是显示为单个页面。输入以下命令： hexo n page &quot;页面名称&quot; 命令执行完后，就会发现在在Blog/source目录中多了一个文件夹，里面还有一个index.md，这就代表新建了一个页面。 写博文用文本编辑器打开上面新建的博文，如下图所示：新建的页面略有不同，没有tags和categories标签。三个”-“后面就是博文的正文内容，接下来就是正儿八经地撰写博文了。 因为这里博文都是用Markdown语言写的，所以首先需要一个好用的Markdown编辑器。目前只用过MarkdownPad，其实好用的Markdown编辑器一大堆，这里推荐两个方便使用的： 本地编辑器：Haroopad，非常小众的一款Markdown编辑器，左边编辑右边实时预览效果，非常轻便； 在线编辑器：MaHua，也是比较小众的一款Markdown编辑器，但效果确实很棒 现在打开新建的博文，开始编写，具体参考这里的Markdown教程：Markdown——入门指南 发博文依然在 Git Shell 中进入 Blog文件夹，执行下面几条命令，将博客部署到 GitHub 上： hexo clean hexo generate(若要本地预览就先执行 hexo server) hexo deploy 快捷命令： hexo g == hexo generate hexo d == hexo deploy hexo s == hexo server hexo n == hexo new 还能组合使用，如： hexo d -g hexo s --port=4100 刷新你的个人博客，就可以看到新鲜出炉的博文了，赶紧邀请小伙伴们来欣赏吧。 一个可能出现的错误spawn git ENOENT 解决方法在这里：spawn git ENOENT解决方法]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文章咯！]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%86%99%E6%96%87%E7%AB%A0%E5%92%AF%EF%BC%81%2F</url>
    <content type="text"><![CDATA[写文章咯！第一篇文章这个是三级标题哦 列表1 列表2 a 子列表 b 子列表 列表3 Kanson乐园字体是斜线的哟字体是不是加粗了呢 &lt;html&gt; 哈哈 &lt;/html&gt; ··· 我是标题哦 ··· 我的内容是引用的哦]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[String类相关知识点]]></title>
    <url>%2F2020%2F08%2F14%2FString%E7%B1%BB%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[Java语言中String类是否可以被继承？在Java中String类的定义是 1public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;...&#125; 由此，可知String类是不可以被继承的，因为被final修饰的类是不可以被继承的 final关键字可以用来修饰类、成员变量、方法 修饰类被final修饰的类就不能被其他类继承了，设计类的时候如果不想这个类被其他类继承或者考虑一些安全因素，可以使用final修饰，否则尽量不要把类设计成final的。同时，类中所有的方法也被隐式的变为final方法。 修饰变量首先，变量分为基本数据类型和引用数据类型。被final修饰的基础类型和引用类型都是不能再次赋值的，这就说明被final修饰的变量是不可变的，相当于常量。因此，final修饰的变量必须被初始化，初始化可以在声明变量的时候，也可以在构造函数中初始化。 final修饰的变量和普通变量有什么区别 被final修饰的变量在使用的时候可以直接替换，因为其本身在编译期就可以确定下来是固定不可变的，对应值就会被放到字符串常量池中，而普通变量在编译阶段是一个变量，不能确定对应的值。 只有在编译阶段确定下来的字符串才会被放到字符串常量池中 修饰方法 final修饰的方法，不能被子类覆盖 仍然可以正常被调用 可以实现重载 static关键字定义静态常量 1static final String NAME = "hello java"; static表示唯一，独此一份，表示静态；final用来表示不可变 二者结合就是静态常量，全局唯一，同时与final不同，只被static修饰的变量，其值可以被修改。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现在是北京时间2020年5月16日早上7:37，我在杭州的家里早早起床]]></title>
    <url>%2F2020%2F05%2F16%2F2020-05-16%2F</url>
    <content type="text"><![CDATA[现在是北京时间2020年5月16日早上7:37，我在杭州的家里早早起床（大概不到6点就醒了），洗漱后出去买了早餐，这个时间要比平时出门上班早1个小时，难得的自由与清闲啊~~有木有？！昨天傍晚下了小雨，和同事们一起吃过饭后惊喜地发现雨停了，开心！所以出去走走都觉得好凉爽，好放松！ 我的工作是单休，所以今天也是工作日，不过初创小公司，注重结果大于形式，我们都在家办公还是比较人性化的。作为一名软件工程师，我深知自己还很菜，但是大家一起组成一个团队就很强了（所以更得投入精力成为团队的扛把子吖，小克同学听到木有？！），多人协作，直接沟通，交流碰撞的同时每个人的头脑都能活跃起来，思考并输出想法，最终达成共识从而形成有效的解决方案，朴素而务实的工程师文化大概不过如此吧~~ 最近负责的系统刚上线不久，一堆bug，一堆需求，痛并快乐着~~测试不到位，用例不足，完整的测试意识不强，后面要重视起来。不要什么事都那么独立地做，有些事一个人也不可能做到极致，要有意识地去找别人合作！ 本周碎碎念：要变得强大起来，要追求极致，要快乐而投入地工作，要有品质有感情的生活……要活得漂亮！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》之内存划分与溢出异常]]></title>
    <url>%2F2019%2F12%2F05%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E4%B9%8B%E5%86%85%E5%AD%98%E5%88%92%E5%88%86%E4%B8%8E%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[虚拟机内存管理JVM所管理的内存包括以下几个运行时数据区域： 不同虚拟机实现可能略微有所不同，但都会遵从 Java 虚拟机规范，Java 8 虚拟机规范规定，Java 虚拟机所管理的内存将会包括以下几个区域： 程序计数器（Program Counter Register） Java 虚拟机栈（Java Virtual Machine Stacks） 本地方法栈（Native Method Stack） Java 堆（Java Heap） 方法区（Methed Area） ① 程序计数器 程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于 JVM 的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，也就是任何时刻，一个处理器（或者说一个内核）都只会执行一条线程中的指令。因此为了线程切换后能恢复到正确的执行位置，每个线程都有独立的程序计数器。 如果线程正在执行 Java 中的方法，程序计数器记录的就是正在执行虚拟机字节码指令的地址，如果是 Native 方法，这个计数器就为空（undefined），因此该内存区域是唯一一个在 Java 虚拟机规范中没有规定 OutOfMemoryError 的区域。 ② Java 虚拟机栈 Java 虚拟机栈（Java Virtual Machine Stacks）描述的是 Java 方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应着一个栈帧在虚拟机栈中入栈到出栈的过程。Java虚拟机规范中规定了2种异常状况： 如果线程请求的栈深度大于虚拟机所允许的栈深度就会抛出 StackOverflowError 异常。 如果虚拟机是可以动态扩展的，如果扩展时无法申请到足够的内存就会抛出 OutOfMemoryError 异常。 ③ 本地方法栈 本地方法栈（Native Method Stack）与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的。 在 Java 虚拟机规范中对于本地方法栈没有特殊的要求，虚拟机可以自由的实现它，因此在 Sun HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一了。 ④ Java 堆 Java 堆（Java Heap）是 JVM 中内存最大的一块，是被所有线程共享的，在虚拟机启动时候创建，Java 堆唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化的技术将会导致一些微妙的变化，所有的对象都分配在堆上渐渐变得不那么绝对了。 如果在堆中没有内存完成实例分配，并且堆不可以再扩展时，将会抛出 OutOfMemoryError。 Java 虚拟机规范规定，Java 堆可以处在物理上不连续的内存空间中，只要逻辑上连续即可，就像我们的磁盘空间一样。在实现上也可以是固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是可扩展的，通过 -Xmx 和 -Xms 控制。 Java堆是GC收集器管理的主要区域。 ⑤ 方法区 方法区（Methed Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。 很多人把方法区称作“永久代”（Permanent Generation），本质上两者并不等价，只是 HotSpot 虚拟机垃圾回收器团队把 GC 分代收集扩展到了方法区，或者说是用来永久代来实现方法区而已，这样能省去专门为方法区编写内存管理的代码，但是在 JDK 8 也移除了“永久代”，使用 Native Memory 来实现方法区。 当方法无法满足内存分配需求时会抛出 OutOfMemoryError 异常。 相关面试题：1.什么是 JVM？它有什么作用？答：JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，顾名思义它是一个虚拟计算机，也是 Java 程序能够实现跨平台的基础。它的作用是加载 Java 程序，把字节码翻译成机器码再交由 CPU 执行的一个虚拟计算器。 2.JVM 主要组成部分有哪些？答：JVM 主要组成部分如下： 类加载器（ClassLoader） 运行时数据区（Runtime Data Area） 执行引擎（Execution Engine） 本地库接口（Native Interface） 3.JVM 是如何工作的？答：首先程序在执行之前先要把 Java 代码（.java）转换成字节码（.class），JVM 通过类加载器（ClassLoader）把字节码加载到内存中，但字节码文件是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine） 将字节码翻译成底层机器码，再交由 CPU 去执行，CPU 执行的过程中需要调用本地库接口（Native Interface）来完成整个程序的运行。 4.变量存储？栈区存放函数的参数值，局部变量的值等；堆区存放的是程序员创建的对象；全局区存放全局变量和静态变量；常量区存放常量字符串 5.内存溢出和内存泄漏的区别是什么？答：内存溢出和内存泄漏的区别如下： 内存溢出是指程序申请内存时，没有足够的内存，就会报错 OutOfMemoryError； 内存泄漏是指垃圾对象无法回收，可以使用 Memory Analyzer 等工具排除内存泄漏。 对象的创建：使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Swap算法的收集器时，通常采用空闲列表 不同内存分区存放不同数据类型的不清晰的认识： Java内存：堆内存、栈内存、方法区 堆内存：基本数据类型，引用类型 栈内存：递归无终止条件会导致StackOverFlowError，栈空间的耗尽 方法区：函数，方法名]]></content>
      <tags>
        <tag>Java, JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《深入理解Java虚拟机》之GC]]></title>
    <url>%2F2019%2F12%2F05%2F%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B%E4%B9%8BGC%2F</url>
    <content type="text"><![CDATA[内存动态分配和垃圾收集技术GC：哪些内存需要回收？什么时候回收？如何回收？ 当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对内存动态分配和垃圾收集技术实施必要的监控和调节。 垃圾收集器关注的是Java堆和方法区中的动态分配和回收的内存。 判断对象存活与否？ 1、引用计数算法：主流的Java虚拟机未采用，很难解决对象之间相互循环引用的问题 2、可达性分析算法：判定对象是否可回收 对象真正死亡：至少经历两次标记过程：finalize()最多执行一次 一、垃圾收集算法：1.标记-清除算法 Mark and Sweep分为标记和清除两个阶段，是最基础的收集算法，主要不足：1、效率问题；2、空间问题：标记清除之后会产生大量不连续的内存碎片，导致之后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次GC。 2.复制算法 Copying一块内存平均划分为2块，一块空闲，一块存储，当回收的时候，把另一半中仍然存活的复制过来，并将其内存全部收回 Eden:Survivor = 8:1 3.标记-整理算法 Mark-Compact标记以后，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 4.分代收集算法一般将Java堆分为新生代和老年代，对于新生代，每次收集时都发现有大批对象死去，只有少量存活，就选用复制算法，只需付出少量复制成本即可完成回收。而老年代中对象存活率高，没有额外空间对其进行担保，就必须使用“标记清除”或者“标记整理”算法回收。 Young区（新生代代），Elden区（老年代），Survive区（永久代）：S0，S1，Meta Space，S0:S1=9:1 Java内存：堆内存、栈内存、方法区 堆内存：基本数据类型，引用类型 栈内存：递归无终止条件会导致StackOverFlowError，栈空间的耗尽 方法区：函数，方法名 二、垃圾回收器收集算法是内存回收的方法论，垃圾收集器是内存回收的具体实现。 7种作用于不同分代的收集器： 特性、基本原理和使用场景： 重点分析CMS和G1相对复杂的收集器，了解运作细节。 新生代：Serial、ParNew、Praralell Scavenge 老年代：CMS、Serial Old、Parallel Old、G1 1、Serial收集器单线程，stop the world，是虚拟机运行在Client模式下的默认新生代收集器，与其他收集器的单线程相比，简单而高效。对于限定单个CPU的环境而言，Serial由于没有线程交互的开销，可以获得最高的单线程收集效率。 新生代采取复制算法，而老年代采取标记-整理算法。 2、ParNew收集器是Serial的多线程版本，行为包括：Serial可用的所有控制参数、收集算法、stop the world、对象分配规则、回收策略。这两种收集器共用了不少代码。 -XX:ParallelGCThreads用来限制垃圾收集的线程数，ParNew收集器是使用-XX:+UseConcMarkSweepGC后的默认新生代收集器。可以使用-XX:+UseParNewGC强制使用。 3、Praralell Scavenge（清除）收集器复制算法，并行的多线程收集器，目标是达到可控制的吞吐量（吞吐量优先收集器），吞吐量=运行用户代码时间/(运行用户代码时间+GC时间)，低停顿时间有利于提高响应速度，因而适合交互较多的程序，高吞吐量可以高效利用CPU时间，尽快完成程序的运算任务，主要适合后台计算。 精确控制吞吐量的参数：-XX:MaxGCPauseMillis（控制最大GC停顿时间），-XX:GCTimeRatio（直接设置吞吐量大小） GC停顿时间缩短是以牺牲吞吐量和新生代空间为代价的。 自适应调节策略：-XX:+UseAdaptiveSizePolicy 开启GC自适应调节策略后，无需手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等参数，虚拟机会根据当前系统运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 4、Serial Old收集器单线程、标记-整理算法、老年代，给Client模式的VM使用，Server模式下，作为CMS的后备预案（在并发收集发生Concurrent Mode failure时使用） 5、Parallel Old收集器是Praralell Scavenge的老年代版本，多线程，标记-整理算法，在注重吞吐量以及CPU资源敏感的场合，可以优先考虑使用Praralell Scavenge+Praralell Old组合。 相关面试题：1.哪些对象可以作为引用链的 Root 对象？答：引用链的 Root 对象可以为以下内容： Java 虚拟机栈中的引用对象； 本地方法栈中 JNI（既一般说的 Native 方法）引用的对象； 方法区中类静态常量的引用对象； 方法区中常量的引用对象。 2.对象引用关系都有哪些？答：不管是引用计数法还是可达性分析算法都与对象的“引用”有关，这说明对象的引用决定了对象的生死，对象的引用关系如下。 强引用：在代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。 软引用：是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM 认为内存不足时，才会去试图回收软引用指向的对象，JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。 弱引用：非必需对象，但它的强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。 虚引用：也称为幽灵引用或幻影引用，是最弱的一种引用关系，无法通过虚引用来获取一个对象实例，为对象设置虚引用的目的只有一个，就是当这个对象被收集器回收时收到一条系统通知。 3.垃圾回收算法有哪些？答：垃圾回收算法如下。 引用计数器算法：引用计算器判断对象是否存活的算法是这样的，给每一个对象设置一个引用计数器，每当有一个地方引用这个对象的时候，计数器就加 1，与之相反，每当引用失效的时候就减 1。 可达性分析算法：在主流的语言的主流实现中，比如 Java、C#，甚至是古老的 Lisp 都是使用的可达性分析算法来判断对象是否存活的。这个算法的核心思路就是通过一些列的“GC Roots”对象作为起始点，从这些对象开始往下搜索，搜索所经过的路径称之为“引用链”。当一个对象到 GC Roots 没有任何引用链相连的时候，证明此对象是可以被回收的。 复制算法：复制算法是将内存分为大小相同的两块，当这一块使用完了，就把当前存活的对象复制到另一块，然后一次性清空当前区块。此算法的缺点是只能利用一半的内存空间。 标记-清除算法：此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。 标记-整理：此算法结合了“标记-清除”和“复制”两个算法的优点。分为两个阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。 4.垃圾回收的分类都有哪些？答：垃圾回收的分类如下： 新生代回收器：Serial、ParNew、Parallel Scavenge 老年代回收器：Serial Old、Parallel Old、CMS 整堆回收器：G1 5.分代垃圾回收器的组成部分有哪些？答：分代垃圾回收器是由：新生代（Young Generation）和老生代（Tenured Generation）组成的，默认情况下新生代和老生代的内存比例是 1:2。 6.新生代的组成部分有哪些？答：新生代是由：Eden、Form Survivor、To Survivor 三个区域组成的，它们内存默认占比是 8:1:1。 7.新生代垃圾回收是怎么执行的？答：新生代垃圾回收的执行过程如下： ① Eden 区 + From Survivor 区存活着的对象复制到 To Survivor 区；② 清空 Eden 和 From Survivor 分区；③ From Survivor 和 To Survivor 分区交换（From 变 To，To 变 From）。 8.为什么新生代有两个 Survivor 分区？答：当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。 如果 Survivor 是 0 的话，也就是说新生代只有一个 Eden 分区，每次垃圾回收之后，存活的对象都会进入老生代，这样老生代的内存空间很快就被占满了，从而触发最耗时的 Full GC ，显然这样的收集器的效率是我们完全不能接受的。 如果 Survivor 分区是 1 个的话，假设把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低不是最佳的方案。但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作，显然这种垃圾回收器最大的问题就在于，需要频繁进行垃圾回收。 如果 Survivor 分区有 2 个分区，我们就可以把 Eden、From Survivor、To Survivor 分区内存比例设置为 8:1:1 ，那么任何时候新生代内存的利用率都 90% ，这样空间利用率基本是符合预期的。再者就是虚拟机的大部分对象都符合“朝生夕死”的特性，因此每次新对象的产生都在空间占比比较大的 Eden 区，垃圾回收之后再把存活的对象方法存入 Survivor 区，如果是 Survivor 区存活的对象，那么“年龄”就 +1 ，当年龄增长到 15 （可通过 -XX:+MaxTenuringThreshold 设定）对象就升级到老生代。 经过以上对比，可以得出结论，当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。 9.什么是 CMS 垃圾回收器？答：CMS（Concurrent Mark Sweep）一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。 10.CMS 垃圾回收器有哪些优缺点？答：CMS 垃圾回收器的优点是使用多线程，标记清除垃圾的，它缺点如下。 对 CPU 资源要求敏感：CMS 回收器过分依赖于多线程环境，默认情况下，开启的线程数为（CPU 的数量 + 3）/ 4，当 CPU 数量少于 4 个时，CMS 对用户本身的操作的影响将会很大，因为要分出一半的运算能力去执行回收器线程； CMS 无法清除浮动垃圾：浮动垃圾指的是 CMS 清除垃圾的时候，还有用户线程产生新的垃圾，这部分未被标记的垃圾叫做“浮动垃圾”，只能在下次 GC 的时候进行清除； CMS 垃圾回收会产生大量空间碎片：CMS 使用的是标记-清除算法，所有在垃圾回收的时候回产生大量的空间碎片。 11.什么是 G1 垃圾回收器？答：G1 垃圾回收器是一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS CG，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。 G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 Region。Region 之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。 12.垃圾回收的调优参数有哪些？答：垃圾回收的常用调优如下： -Xmx:512 设置最大堆内存为 512 M； -Xms:215 初始堆内存为 215 M； -XX:MaxNewSize 设置最大年轻区内存； -XX:MaxTenuringThreshold=5 设置新生代对象经过 5 次 GC 晋升到老年代； -XX:PretrnureSizeThreshold 设置大对象的值，超过这个值的大对象直接进入老生代； -XX:NewRatio 设置分代垃圾回收器新生代和老生代内存占比； -XX:SurvivorRatio 设置新生代 Eden、Form Survivor、To Survivor 占比。]]></content>
      <tags>
        <tag>Java, JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发包(JUC)源码分析]]></title>
    <url>%2F2019%2F11%2F30%2FJDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BConcurrent%2F</url>
    <content type="text"><![CDATA[Java 并发包(JUC)下面的工具类，在实际工作中都有哪些应用场景呢？考察点：多线程并发编程的技术广度，实践经验 具体某个类的原理，比如ThreadPoolExcecutor 为什么要看ConcurrentHashMap JUC 下有哪些工具类？ 我自己用过的场景。用过countdownlatch 多接口并发调用，还有Fork join做过并行计算，用过atomicinteger 并发下载数量限制。。 ConcurrentSkipListMap 用来存一致性hash的环； Countdownlatch 一个服务需要多个模块（线程）时，都启动才宣布服务启动； atomicinteger做在线数量统计； ScheduledThreadPoolExecutor 做定时任务； ReentrantLock 做可中断锁，避免死锁； 这下面可以主要分几类吧 线程间通信工具类，如Semaphore ,、CountDownLatch、Future等等，这种也经常用，特别是在写多线程高并发的程序时，结合通信工具和锁把线程编排的符合你的预期执行 锁，JUC提供了各种在某些场景下比synchronized更合适的高级锁实现，包括读写锁，互斥锁等等，因其多数基于CAS这种乐观锁实现，性能一般要由于synchronized内置锁，而且结合Cdondition更灵活可控。 不过个人觉得，这些锁除了jdk以及一些知名框架中使用外，我们日常工作synchronized就已经够用了，很少会用到，就算为了追求极致的性能，也往往先从架构方面入手 原子包装类 ，这个经常用，一两行代码既可以保证线程安全，又可以获得比synchronized内置锁更好的性能，何乐而不为呢 线程安全的集合， 这里面包含了一些基于锁分解、分段锁、CAS等机制性能优良且线程安全的集合类，一般在多线程业务中，只要有共享访问的集合，可能不管三七二十一直接用这些同步集合 线程池工具类，这就更不用说了，目前几乎很少有项目不用线程池的 场景的话，非常多 1.生产消费问题，这是大头，大到转账取钱问题，小到并发读写队列，只要有对共享数据的并发读写访问，都可以算 2.秒杀场景，红包、促销等等，其实这也勉强可以算生产消费问题 3.研发框架，目前各种web 服务 、rpc服务、schedule服务等等，都是多线程服务，JUC的工具是保证并发服务高可用高性能的基础]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码分析之Map]]></title>
    <url>%2F2019%2F10%2F09%2FJDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BMap%2F</url>
    <content type="text"><![CDATA[java.util.Map Map 简介Map 常用的实现类如下： Hashtable：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用。 HashMap：最常用的哈希表实现，如果程序中没有多线程的需求，HashMap 是一个很好的选择，支持 null 键和值，如果在多线程中可用 ConcurrentHashMap 替代。 TreeMap：基于红黑树的一种提供顺序访问的 Map，自身实现了 key 的自然排序，也可以指定 Comparator 来自定义排序。 LinkedHashMap：HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。 HashMap 数据结构HashMap 底层的数据是数组被成为哈希桶，每个桶存放的是链表，链表中的每个节点，就是 HashMap 中的每个元素。在 JDK 8 当链表长度大于等于 8 时，就会转成红黑树的数据结构，以提升查询和插入的效率。 HashMap 数据结构，如下图： HashMap 重要方法1）添加方法：put(Object key, Object value)执行流程如下： 对 key 进行 hash 操作，计算存储 index； 判断是否有哈希碰撞，如果没碰撞直接放到哈希桶里，如果有碰撞则以链表的形式存储； 判断已有元素的类型，决定是追加树还是追加链表，当链表大于等于 8 时，把链表转换成红黑树； 如果节点已经存在就替换旧值； 判断是否超过阀值，如果超过就要扩容。 put() 执行流程图如下： 2）获取方法：get(Object key)执行流程如下： 首先比对首节点，如果首节点的 hash 值和 key 的 hash 值相同，并且首节点的键对象和 key 相同（地址相同或 equals 相等），则返回该节点； 如果首节点比对不相同、那么看看是否存在下一个节点，如果存在的话，可以继续比对，如果不存在就意味着 key 没有匹配的键值对。 相关面试题1.Map 常见实现类有哪些？答：Map 的常见实现类如下列表： Hashtable：Java 早期提供的一个哈希表实现，它是线程安全的，不支持 null 键和值，因为它的性能不如 ConcurrentHashMap，所以很少被推荐使用； HashMap：最常用的哈希表实现，如果程序中没有多线程的需求，HashMap 是一个很好的选择，支持 null 键和值，如果在多线程中可用 ConcurrentHashMap 替代； TreeMap：基于红黑树的一种提供顺序访问的 Map，自身实现了 key 的自然排序，也可以指定的 Comparator 来自定义排序； LinkedHashMap：HashMap 的一个子类，保存了记录的插入顺序，可在遍历时保持与插入一样的顺序。 2.使用 HashMap 可能会遇到什么问题？如何避免？答：HashMap 在并发场景中可能出现死循环的问题，这是因为 HashMap 在扩容的时候会对链表进行一次倒序处理，假设两个线程同时执行扩容操作，第一个线程正在执行 B→A 的时候，第二个线程又执行了 A→B ，这个时候就会出现 B→A→B 的问题，造成死循环。解决的方法：升级 JDK 版本，在 JDK 8 之后扩容不会再进行倒序，因此死循环的问题得到了极大的改善，但这不是终极的方案，因为 HashMap 本来就不是用在多线程版本下的，如果是多线程可使用 ConcurrentHashMap 替代 HashMap。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK源码分析之Collection]]></title>
    <url>%2F2019%2F10%2F08%2FJDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BCollection%2F</url>
    <content type="text"><![CDATA[集合的继承关系图中，看出集合的根节点是 Collection，而 Collection 下又提供了两大常用集合，分别是： List：使用最多的有序集合，提供方便的新增、修改、删除的操作； Set：集合不允许有重复的元素，在许多需要保证元素唯一性的场景中使用。 集合使用： 1）VectorVector 是 Java 早期提供的线程安全的有序集合，如果不需要线程安全，不建议使用此集合，毕竟同步是有线程开销的。Stack继承了Vector 使用示例代码： 12345Vector vector = new Vector();vector.add("dog");vector.add("cat");vector.remove("cat");System.out.println(vector); 程序执行结果：[dog] 2）ArrayListArrayList 是最常见的非线程安全的有序集合，因为内部是数组存储的，所以随机访问效率很高，但非尾部的插入和删除性能较低，如果在中间插入元素，之后的所有元素都要后移。ArrayList 的使用与 Vector 类似。 3）LinkedListLinkedList 是使用双向链表数据结构实现的，因此增加和删除效率比较高，而随机访问效率较差。 LinkedList 除了包含以上两个类的操作方法之外，还新增了几个操作方法，如 offer() 、peek() 等，具体详情，请参考以下代码： 12345678910LinkedList linkedList = new LinkedList();// 添加元素linkedList.offer("bird");linkedList.push("cat");linkedList.push("dog");// 获取第一个元素System.out.println(linkedList.peek());// 获取第一个元素，并删除此元素System.out.println(linkedList.poll());System.out.println(linkedList); 程序的执行结果： 123dogdog[cat, bird] 4）HashSetHashSet 是一个没有重复元素的集合。虽然它是 Set 集合的子类，实际却为 HashMap 的实例，相关源码如下： 123public HashSet() &#123; map = new HashMap&lt;&gt;();&#125; 因此 HashSet 是无序集合，没有办法保证元素的顺序性。 HashSet 默认容量为 16，每次扩充 0.75 倍，相关源码如下： 1234public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125; HashSet 的使用与 Vector 类似。 5）TreeSetTreeSet 集合实现了自动排序，也就是说 TreeSet 会把你插入数据进行自动排序。 示例代码如下： 123456TreeSet treeSet = new TreeSet();treeSet.add(&quot;dog&quot;);treeSet.add(&quot;camel&quot;);treeSet.add(&quot;cat&quot;);treeSet.add(&quot;ant&quot;);System.out.println(treeSet); 程序执行结果：[ant, camel, cat, dog] 可以看出，TreeSet 的使用与 Vector 类似，只是实现了自动排序。 6）LinkedHashSetLinkedHashSet 是按照元素的 hashCode 值来决定元素的存储位置，但同时又使用链表来维护元素的次序，这样使得它看起来像是按照插入顺序保存的。 相关面试题1.List 和 Set 有什么区别？ List 允许有多个 null 值，Set 只允许有一个 null 值； List 允许有重复元素，Set 不允许有重复元素； List 可以保证每个元素的存储顺序，Set 无法保证元素的存储顺序。 2.Collection 和 Collections 有什么区别？答：Collection 和 Collections 的区别如下： Collection 是集合类的上级接口，继承它的主要有 List 和 Set； Collections 是针对集合类的一个帮助类，它提供了一些列的静态方法实现，如 Collections.sort() 排序、Collections.reverse() 逆序等。 3.LinkedHashSet 如何保证有序和唯一性？答：LinkedHashSet 底层数据结构由哈希表和链表组成，链表保证了元素的有序即存储和取出一致，哈希表保证了元素的唯一性。 4.HashSet 是如何保证数据不可重复的？答：HashSet 的底层其实就是 HashMap，只不过 HashSet 实现了 Set 接口并且把数据作为 K 值，而 V 值一直使用一个相同的虚值来保存，我们可以看到源码： 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;// 调用 HashMap 的 put 方法,PRESENT 是一个至始至终都相同的虚值&#125; 由于 HashMap 的 K 值本身就不允许重复，并且在 HashMap 中如果 K/V 相同时，会用新的 V 覆盖掉旧的 V，然后返回旧的 V，那么在 HashSet 中执行这一句话始终会返回一个 false，导致插入失败，这样就保证了数据的不可重复性。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea快捷键使用整理]]></title>
    <url>%2F2019%2F07%2F23%2Fidea%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[1、格式化编辑代码 Ctrl+Alt+L 2、sout 快速打印 一键格式化代碼： Ctrl+Alt+L 全局搜索替换：ctrl+shift+r 强大的搜索功能，shift+shift (无论您想要搜啥都能找到) ctrl+shift+R==搜索类 CTRL+N：按照类名搜索类 【常规】 Ctrl+Shift + Enter，语句完成 “！”，否定完成，输入表达式时按 “！”键 Ctrl+E，最近的文件 Ctrl+Shift+E，最近更改的文件 Shift+Click，可以关闭文件 Ctrl+[ OR ]，可以跑到大括号的开头与结尾 Ctrl+F12，可以显示当前文件的结构 Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择 Ctrl+N，可以快速打开类 Ctrl+Shift+N，可以快速打开文件 Alt+Q，可以看到当前方法的声明 Ctrl+P，可以显示参数信息 Ctrl+Shift+Insert，可以选择剪贴板内容并插入 Alt+Insert，可以生成构造器/Getter/Setter等 Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义 Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch Ctrl+Enter，导入包，自动修正 Ctrl+Alt+L，格式化代码 Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作 Ctrl+Alt+O，优化导入的类和包 Ctrl+R，替换文本 Ctrl+F，查找文本 Ctrl+Shift+Space，自动补全代码 Ctrl+空格，代码提示（与系统输入法快捷键冲突） Ctrl+Shift+Alt+N，查找类中的方法或变量 Alt+Shift+C，最近的更改 Alt+Shift+Up/Down，上/下移一行 Shift+F6，重构 - 重命名 Ctrl+X，删除行 Ctrl+D，复制行 Ctrl+/或Ctrl+Shift+/，注释（//或者/**/） Ctrl+J，自动代码（例如：serr） Ctrl+Alt+J，用动态模板环绕 Ctrl+H，显示类结构图（类的继承层次） Ctrl+Q，显示注释文档 Alt+F1，查找代码所在位置 Alt+1，快速打开或隐藏工程面板 Ctrl+Alt+left/right，返回至上次浏览的位置 Alt+left/right，切换代码视图 Alt+Up/Down，在方法间快速移动定位 Ctrl+Shift+Up/Down，向上/下移动语句 F2 或 Shift+F2，高亮错误或警告快速定位 Tab，代码标签输入完成后，按 Tab，生成代码 Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失 Alt+F3，逐个往下查找相同文本，并高亮显示 Ctrl+Up/Down，光标中转到第一行或最后一行下 Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处） Ctrl+Alt+B，跳转到方法实现处 Ctrl+Shift+Backspace，跳转到上次编辑的地方 Ctrl+O，重写方法 Ctrl+Alt+Space，类名自动完成 Ctrl+Alt+Up/Down，快速跳转搜索结果 Ctrl+Shift+J，整合两行 Alt+F8，计算变量值 Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本 Ctrl+Alt+Shift+V，简单粘贴 Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口 F12，把焦点从编辑器移到最近使用的工具窗口 Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器 Ctrl+W，可以选择单词继而语句继而行继而函数 Ctrl+Shift+W，取消选择光标所在词 Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置 Ctrl+I，实现方法 Ctrl+Shift+U，大小写转化 Ctrl+Y，删除当前行 Shift+Enter，向下插入新行 psvm/sout，main/System.out.println(); Ctrl+J，查看更多 Ctrl+Shift+F，全局查找 Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找 Ctrl+Shift+S，高级搜索 Ctrl+U，转到父类 Ctrl+Alt+S，打开设置对话框 Alt+Shift+Inert，开启/关闭列选择模式 Ctrl+Alt+Shift+S，打开当前项目/模块属性 Ctrl+G，定位行 Alt+Home，跳转到导航栏 Ctrl+Enter，上插一行 Ctrl+Backspace，按单词删除 Ctrl+”+/-“，当前方法展开、折叠 Ctrl+Shift+”+/-“，全部展开、折叠 【调试部分、编译】 Ctrl+F2，停止 Alt+Shift+F9，选择 Debug Alt+Shift+F10，选择 Run Ctrl+Shift+F9，编译 Ctrl+Shift+F10，运行 Ctrl+Shift+F8，查看断点 F8，步过 F7，步入 Shift+F7，智能步入 Shift+F8，步出 Alt+Shift+F8，强制步过 Alt+Shift+F7，强制步入 Alt+F9，运行至光标处 Ctrl+Alt+F9，强制运行至光标处 F9，恢复程序 Alt+F10，定位到断点 Ctrl+F8，切换行断点 Ctrl+F9，生成项目 Alt+1，项目 Alt+2，收藏 Alt+6，TODO Alt+7，结构 Ctrl+Shift+C，复制路径 Ctrl+Alt+Shift+C，复制引用，必须选择类名 Ctrl+Alt+Y，同步 Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单） Shift+F12，还原默认布局 Ctrl+Shift+F12，隐藏/恢复所有窗口 Ctrl+F4，关闭 Ctrl+Shift+F4，关闭活动选项卡 Ctrl+Tab，转到下一个拆分器 Ctrl+Shift+Tab，转到上一个拆分器 【重构】 Ctrl+Alt+Shift+T，弹出重构菜单 Shift+F6，重命名 F6，移动 F5，复制 Alt+Delete，安全删除 Ctrl+Alt+N，内联 【查找】 Ctrl+F，查找 Ctrl+R，替换 F3，查找下一个 Shift+F3，查找上一个 Ctrl+Shift+F，在路径中查找 Ctrl+Shift+R，在路径中替换 Ctrl+Shift+S，搜索结构 Ctrl+Shift+M，替换结构 Alt+F7，查找用法 Ctrl+Alt+F7，显示用法 Ctrl+F7，在文件中查找用法 Ctrl+Shift+F7，在文件中高亮显示用法 【VCS】 Alt+~，VCS 操作菜单 Ctrl+K，提交更改 Ctrl+T，更新项目 Ctrl+Alt+Shift+D，显示变化 以上皆由网络整理，不作商业用途，与本人无关]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue_cli脚手架配置]]></title>
    <url>%2F2019%2F07%2F20%2FVue_cli%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[npm uninstall vue-cli -g 卸载旧版本，在安装新版本。 npm install –global vue-cli Vue前端开发环境： 技术 版本 说明 node v10.16.0 node编译环境 npm 6.9.0 npm包管理工具 Vue 2.9.6 前端框架 Vue-router 3.0.2 前端路由框架 Vuex 3.1.0 vue状态管理组件 Vue-cli ———— Vue脚手架 Element-ui 2.7.0 前端UI框架 Echarts 4.2.1 数据可视化框架 Uni-app ———— 跨平台前端框架 Mockjs 1.0.1-beta3 模拟后端数据 Axios 0.18.0 基于Promise的Http库 Js-cookie 2.2.0 Cookie组件 Jsonlint 1.6.3 Json解析组件 screenfull 4.2.0 全屏组件 Xlsx 0.14.1 Excel表导出组件 Webpack ———— 模板打包器 123456789101112# 安装vue $ npm install vue@2.1.6 # 全局安装 vue-cli $ npm install --global vue-cli # 创建一个基于 webpack 模板的新项目my-project $ vue init webpack my-project # 进入项目目录 $ cd my-project # 安装依赖，走你 $ npm install # 运行项目 $ npm run dev LovMat产品原型构思综述身边能接触到的年轻人大概都是18~25岁左右，25以上的大概都是有几年工作经验或者研究生毕业没多久的。有感于日常工作、学习之外的生活过于枯燥，虽然看书、追剧、运动也是自己的爱好，但毕竟只是一个人的狂欢，而个人性格又相对孤僻，因此有必要针对使用中或曾经使用过的社交软件，以及遇到的萝莉御姐数据进行分析，将自身的喜好以客观、理性的方式呈现出来，给予个人指导。包括： 对话的内容，对话的时间，对话时的心境等等； 共同话题，交流频率； 有哪些值得纪念的瞬间； 有没有故事发生； 自己是否对自己有了更好的认知？ 未来考虑工作应如何协调好享受爱情生活与享受学习生活； 哪里的妹子是什么性格、特点，哪里的经济、创新氛围最为适合； 哪里的工作环境更符合自身性格、追求； 什么时间节点适合做什么梦； 什么时候独立创业； 我与世界，万物一体。 及时止损，被拉黑举报，什么情况会触发越界机制； 如何能不越界，而且可以拉近彼此联系； 线上线下心理学 消费与决策 眼神，心理，微表情 人性 延迟满足 领导与下属，组织与个体 万事到头 – 信息管理系统 – 算法数据处理分析系统 – 用户群与地理位置、经济时代背景研究 – 个人喜好，自我研究 – 技术更迭，博客维护 – 发表时评，交流技术，传递思维与认知 – 知识创富，技能迭代，马不停蹄 – 将自己的生活无限的自动化，程序化，进化为一个超级AI 使用vue写一个信息管理系统界面 – 租房子：需求：经济、实惠 关联需求：找工作，找对象，找朋友，聚会，玩耍，泡茶，养生，看书，一条龙服务。 高级需求：结交志同道合的朋友，享受高级生活； 功能清单 管理员注册登录，信息维护 萝莉御姐信息管理 个人财务管理 个人技能管理 个人职业管理 个人健康管理 个人生活管理 个人情感管理 个人读书管理 前后端分离 后端提供请求响应的url触发方法，机制 前端只提供客户端访问调用入口界面 后端搞定：业务逻辑、健壮安全性、稳定可靠性、可维护可扩展性、各种流量下的负载均衡、网络安全攻防 前端搞定各种用户交互、体验、实现用户需求 移动端（Android、iOS） 小程序 人工智能加持 算法]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务技术栈]]></title>
    <url>%2F2019%2F07%2F14%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1Web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF%E6%A0%88%2F</url>
    <content type="text"><![CDATA[前端技术栈 技术 版本 说明 Vue 2.6.10 前端框架 Vue-router 3.0.2 前端路由框架 Vuex 3.1.0 vue状态管理组件 Vue-cli ———— Vue脚手架 Element-ui 2.7.0 前端UI框架 Echarts 4.2.1 数据可视化框架 Uni-app ———— 跨平台前端框架 Mockjs 1.0.1-beta3 模拟后端数据 Axios 0.18.0 基于Promise的Http库 Js-cookie 2.2.0 Cookie组件 Jsonlint 1.6.3 Json解析组件 screenfull 4.2.0 全屏组件 Xlsx 0.14.1 Excel表导出组件 Webpack ———— 模板打包器 后端技术栈 技术 版本 说明 Spring Cloud Netflix Finchley.RELEASE 分布式全家桶 Spring Cloud Eureka 2.0.0.RELEASE 服务注册 Spring Cloud Zipkin 2.0.0.RELEASE 服务链路 Spring Cloud config 2.0.0.RELEASE 服务配置 Spring Cloud Feign 2.0.0.RELEASE 服务调用 Spring Cloud Zuul 2.0.0.RELEASE 服务网关 Spring Cloud Hystrix 2.0.0.RELEASE 服务熔断 Spring Cloud Turbine 2.0.0.RELEASE 服务熔断监控 Spring Boot Admin 2.0.1 服务监控 Spring Boot 2.0.3.RELEASE 容器+MVC框架 Spring Security 5.1.4.RELEASE 认证和授权框架 MyBatis 3.4.6 ORM框架 MyBatisGenerator 1.3.3 数据层代码生成 PageHelper 5.1.8 MyBatis物理分页插件 Maven 3.6.1 项目管理工具 Swagger2 2.7.0 交互式API文档 Elasticsearch 6.2.2 搜索引擎 kibana 6.2.2 数据分析和可视化平台 LogStash 6.2.2 数据采集引擎 RabbitMq 3.7.14 消息队列 Redis 3.2 缓存 Druid 1.1.10 数据库连接池 OSS 2.5.0 对象存储 JWT 0.9.1 跨域身份验证解决方案 Lombok 1.18.6 简化对象封装工具 Junit 4.12 单元测试框架 Logback 1.2.3 日志框架 Java doc ———— API帮助文档 Docker 18.09.6 应用容器引擎 Docker-compose 18.09.6 容器快速编排]]></content>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java EE开发常用框架梳理]]></title>
    <url>%2F2019%2F07%2F13%2FJavaEE%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、SpringSpring的核心是IoC/DI的容器，它可以帮程序员完成组件之间的依赖关系注入，使得组件之间的依赖达到最小，进而提高组件的重用性，Spring是个低侵入性（invasive）的框架，Spring中的组件并不会意识到它正置身于Spring中，这使得组件可以轻易的从框架中脱离，而几乎不用任何修改，反过来说，组件也可以简单的方式加入至框架中，使得组件甚至框架的整合变得容易。 Spring最为人重视的另一方面是支持AOP（Aspect-Oriented Programming），然而AOP框架只是Spring支持的一个子框架，说Spring框架是AOP框架并不是一件适当的描述，人们对于新奇的 AOP关注映射至Spring上，使得人们对于Spring的关注集中在它的AOP框架上，虽然有所误解，但也突显了Spring的另一个令人关注的特色。 Spring是一个开源框架，是一个轻量级的控制反转（IOC）和面向切面（AOP）的容器框架。 （1）通过控制反转（IOC）达到松耦合，IOC也就是把控制权交出去，在使用中直接得到对象 （2）提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务进行内聚性的开发（例如，商品的入库和出库是业务逻辑，而商品的入库和出库需要统一的日志记录和事务的管理是系统服务，与具体的业务无关，也就是无论业务如何，都要用到系统服务） （3）包含并管理应用对象的配置和生命周期，也就是容器的作用 （4）将简单的组件配置、组合成为复杂的应用，也就是框架的作用 框架与类库的区别： 框架一般是封装了逻辑、高内聚的，类库则是松散的工具组合 框架专注于某一领域，类库则是更通用的 Spring是一系列轻量级Java EE框架的集合：核心容器，Spring上下文，Spring AOP, Spring DAO, Spring ORM, Spring Web, Spring MVC。 IOC：控制反转，控制权的转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责创建和维护，也就是不显示的进行new创建对象 DI（依赖注入）：是控制反转的一种实现方式，由IOC容器在运行期间，动态地将某种依赖关系注入到对象之中。也就是获得依赖对象的过程由自身管理变为由IOC容器主动注入。通过反射机制实现。 控制反转：控制反转的目的：创建对象并组装对象之间的关系。 IOC容器初始化时创建一系列对象，并把对象之间的依赖关系通过注入的方式组织起来，当一个类A中有另外一个B，实例化时，先实例化A这个对象，再实例化B这个对象，然后把B这个对象赋值给A，这就是IOC的组装对象，具体如下图 图解：业务对象进入Spring容器，然后通过配置的元数据，生产出符合我们需要的对象，当我们需要用的时候，直接从Spring容器中取出来用即可，这也就是IOC，应用程序只关心对象的使用，而不关心对象的创建 在IOC容器中，把所有对象称为Bean，Spring利用Bean来管理这些对象，Spring对于Bean和其他的使用有两种方式，一种是基于xml的配置，一种是注解方式。 依赖注入：借鉴http://blog.csdn.net/zhoudaxia/article/details/31763677 控制反转：把传统上由程序代码直接操控的对象的调用权交给外部容器，通过容器来实现对象组件的装配和管理。所谓的“控制反转”就是组件对象的控制权转移了，从程序代码本身转移到了外部容器。 实现控制反转的两种方式：依赖注入和依赖查找。 依赖注入有四种实现方式： 1.基于接口：实现特定接口以供外部容器注入所依赖类型的对象，接口中定义要注入依赖对象的方法。 2.基于setter方法：实现特定属性的public set方法，来让外部容器调用，以传入所依赖类型的对象。 3.基于构造函数：实现特定参数的构造函数，在新建对象时传入所依赖类型的对象。 4.基于注解：基于Java的注解功能，在私有变量前加“@Autowired”等注解，不需要显式的定义以上三种代码，便可以让外部容器传入对应的对象。该方案相当于定义了public 的set方法，但是因为没有真正的set方法，从而不会为了实现依赖注入导致暴露了不该暴露的接口（因为set方法只想让容器访问来注入而不希望其他依赖此类的对象访问）。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库设计及性能优化]]></title>
    <url>%2F2019%2F07%2F08%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据表字段设计：无特殊要求时一般使用varchar（变长存储），根据业务模型设置字段长度，存储灵活的同时SQL执行效率相对变低。而char（定长存储）至少都得占用一定存储空间，但SQL执行效率相对更高。 索引： 分库分表：]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法笔记入门篇（1）-入门模拟]]></title>
    <url>%2F2018%2F10%2F05%2F%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%E5%85%A5%E9%97%A8%E7%AF%87%EF%BC%881%EF%BC%89-%E5%85%A5%E9%97%A8%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术001]]></title>
    <url>%2F2018%2F08%2F02%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF001%2F</url>
    <content type="text"><![CDATA[Java八大基本类型intshortlongbytecharbooleanfloatdouble Java堆内存、栈内存]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux服务端开发环境部署及管理（一）]]></title>
    <url>%2F2018%2F04%2F28%2FLinux%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E5%8F%8A%E7%AE%A1%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Linux服务端开发环境部署及管理（一）Centos7.2 x64环境下Java JDK、MySQL、Tomcat环境的搭建（基于腾讯云平台）腾讯云是个好东西，对于Linux平台不是很熟悉的人而言，开始学习时候很方便，提供各种方便的在线管理方式，如重装系统等。由于版本升级和系统兼容问题，开发中遇到的问题都很琐碎，大概是码农的日常了吧。 官网下载JDK以后，上传至Linux下，安装并设置环境变量。 java -version javac MySQL安装，由于MariaDB的出现，经常会出现系统兼容问题，据说在Centos7.0以后的版本中MySQL都不太兼容，所以需要特别注意。 首先，需要先卸载系统预装的MariaDB，然后下载安装MySQL 在Linux环境下，基本都是命令行操作，所以为了方便起见，建议学习过程中多多动手，多多总结。 Tomcat，类似，安装完后，需要设置环境变量。 启动Tomcat后，可以通过访问外网IP:端口号的方式检验是否安装成功。]]></content>
  </entry>
  <entry>
    <title><![CDATA[完美世界2018春招编程题]]></title>
    <url>%2F2018%2F04%2F27%2F%E5%AE%8C%E7%BE%8E%E4%B8%96%E7%95%8C2018%E6%98%A5%E6%8B%9B%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述：输入若干整数，以空格间隔，要求反转字符序列并打印输出。如： Input: 12 3 456 6789 Output: 6789 456 2 12 源代码：方法一、使用栈存储 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int a[20]; int i = 0; string ss, st; stack&lt;string&gt; s1; char c; do&#123; c = getchar(); if(c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;)&#123; ss += c; &#125;else if(c == &apos; &apos; || c == &apos;\n&apos;)&#123; s1.push(ss); ss = &quot;&quot;; &#125; &#125;while(c != &apos;\n&apos;); while(!s1.empty())&#123; st = s1.top(); s1.pop(); cout &lt;&lt; st; if(!s1.empty())&#123; cout &lt;&lt; &quot; &quot;; &#125;else&#123; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 方法一、使用数组变换存储 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt; using namespace std;int main()&#123; int a[20]; int i = 0; char c; string str = &quot;&quot;; do&#123; c=getchar(); if(c&gt;=&apos;0&apos;&amp;&amp;c&lt;=&apos;9&apos;)&#123; str += c; &#125;else if(c ==&apos; &apos; || c == &apos;\n&apos;) &#123; a[i++] = atoi(str.c_str()); //atoi：将字符串转化为char*对象，再转换成一个整数值 str = &quot;&quot;; &#125; &#125;while(c!=&apos;\n&apos;); for(int j = 0; j &lt; i; j++)&#123; cout &lt;&lt; a[i-j-1]; if(i-j-1 != 0)&#123; cout &lt;&lt; &quot; &quot;; &#125;else&#123; cout &lt;&lt; endl; &#125; &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[构建你的深度学习环境（一）]]></title>
    <url>%2F2018%2F04%2F27%2F%E6%9E%84%E5%BB%BA%E4%BD%A0%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[环境：Centos 7.2，python 2.7.5 1.首先安装好Linux 2.呼出命令行CTRL+ALT+T 3.检测是否安装python，一般Linux默认安装python 直接在命令行输入:python，会显示python的版本号，python2.7.9以上版本默认安装pip。可以看到我的版本号是2.7.5，否则进行步骤 4.eixt()退出python环境。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vuforia开发入门一准备工作]]></title>
    <url>%2F2018%2F04%2F03%2FVuforia%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%E4%B8%80%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Vuforia开发入门1、开发环境配置 a) Android 环境配置 b) Unity3D 下载和安装 2、资源下载 a) 官网注册 b) Samples资源下载]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>AR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视觉领域的部分国内公司]]></title>
    <url>%2F2018%2F03%2F09%2F%E8%A7%86%E8%A7%89%E9%A2%86%E5%9F%9F%E7%9A%84%E9%83%A8%E5%88%86%E5%9B%BD%E5%86%85%E5%85%AC%E5%8F%B8%2F</url>
    <content type="text"><![CDATA[##初创公司 图普科技Face++LinkfaceMinieye知图Cogtu商汤科技Sensetime亮风台Hiscene掌赢科技格灵深瞳DeepPG 凌感科技usens图森TuSimple中科视拓Seetatech(山世光)第四范式 ##上市公司： 百度DL实验室腾讯优图阿里高德暴风魔镜搜狗乐视tv奇虎360京东实验室阿里巴巴联想研究院华为研究院 ##知名外企： 佳能信息索尼研究院富士通研发中心微软研究院英特尔研究院三星研究院]]></content>
      <tags>
        <tag>收藏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub博客管理命令汇总]]></title>
    <url>%2F2018%2F03%2F06%2FHexo-GitHub%E5%8D%9A%E5%AE%A2%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[[Hexo]部署博客及更新博文新建博文使用 Git Shell 进入本地 Blog 文件夹，输入以下命令： hexo n &quot;文章题目&quot; 命令执行完后，就会发现在Blog/source/_posts目录中多了一个文件 博文名.md，这就是我们刚才新建的博文。 新建页面上面新建的博文是显示在单个文章界面，这里新建的页面是作为单个页面显示的，比如分类、标签、归档和关于我，你点击后都是显示为单个页面。输入以下命令： hexo n page &quot;页面名称&quot; 命令执行完后，就会发现在在Blog/source目录中多了一个文件夹，里面还有一个index.md，这就代表新建了一个页面。 写博文用文本编辑器打开上面新建的博文，如下图所示：新建的页面略有不同，没有tags和categories标签。三个”-“后面就是博文的正文内容，接下来就是正儿八经地撰写博文了。 因为这里博文都是用Markdown语言写的，所以首先需要一个好用的Markdown编辑器。目前只用过MarkdownPad，其实好用的Markdown编辑器一大堆，这里推荐两个方便使用的： 本地编辑器：Haroopad，非常小众的一款Markdown编辑器，左边编辑右边实时预览效果，非常轻便； 在线编辑器：MaHua，也是比较小众的一款Markdown编辑器，但效果确实很棒 现在打开新建的博文，开始编写，具体参考这里的Markdown教程：Markdown——入门指南 发博文依然在 Git Shell 中进入 Blog文件夹，执行下面几条命令，将博客部署到 GitHub 上： hexo clean hexo generate(若要本地预览就先执行 hexo server) hexo deploy 快捷命令： hexo g == hexo generate hexo d == hexo deploy hexo s == hexo server hexo n == hexo new 还能组合使用，如： hexo d -g hexo s --port=4100 刷新你的个人博客，就可以看到新鲜出炉的博文了，赶紧邀请小伙伴们来欣赏吧。 一个可能出现的错误spawn git ENOENT 解决方法在这里：spawn git ENOENT解决方法]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文章咯！]]></title>
    <url>%2F2018%2F03%2F06%2F%E5%86%99%E6%96%87%E7%AB%A0%E5%92%AF%EF%BC%81%2F</url>
    <content type="text"><![CDATA[写文章咯！第一篇文章这个是三级标题哦 列表1 列表2 a 子列表 b 子列表 列表3 Kanson乐园字体是斜线的哟字体是不是加粗了呢 &lt;html&gt; 哈哈 &lt;/html&gt; ··· 我是标题哦 ··· 我的内容是引用的哦]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F07%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>

---
title: Java核心技术001
date: 2018-08-02 11:31:08
tags:
---

### Java八大基本类型

8种基本数据类型，其中4种整型，2种浮点类型，1种用于表示Unicode编码的字符单元的字符类型和1种用于表示真值的boolean类型。

int / short / long / byte / float / double / char / boolean

<!--more-->

1字节=8位，即1byte = 8bit，有符号整数，取值范围要先去掉符号位再计算数值大小

* 整型

| 类型  | 存储需求 | bit数 | 取值范围                     |
| ----- | -------- | ----- | ---------------------------- |
| int   | 4 byte   | 32    | -2^31 ~ 2^31-1（有符号整数） |
| short | 2 byte   | 16    | -2^15 ~ 2^15-1               |
| long  | 8 byte   | 64    |                              |
| byte  | 1 byte   | 8     | －128～127                   |

* 浮点型

| 类型   | 存储   | bit  | 备注                                        |
| ------ | ------ | ---- | ------------------------------------------- |
| float  | 4 byte | 32   | float类型的数值有一个后缀F(例如：3.14F)     |
| double | 8 byte | 64   | 没有后缀F的浮点数值(如3.14)默认为double类型 |

* char类型

| 类型 | 存储   | bit  | 备注 |
| ---- | ------ | ---- | ---- |
| char | 2 byte | 16   |      |

* boolean类型

| 类型    | 存储   | bit  | 取值范围    |
| ------- | ------ | ---- | ----------- |
| boolean | 1 byte | 8    | false、true |

Java有一个能够表示任意精度的数学包，通常称为“大数值”(big number)。虽然被称为大数值，但它并不是一种Java类型，而是一个Java对象。如果基本的整数和浮点数精度不能够满足需求，那么可以使用java.math包中的两个很有用的类：BigInteger，BigDecimal。这两个类可以处理包含**任意长度数字序列**的数值。BigInteger类实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。具体的用法可以参见Java API。

### 类型转换

#### long转int

```java
long a = 100L;
int b = (int)a;
```

### 反射原理

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取的以及动态调用对象的方法的功能称为Java的反射机制。

Java学习之反射机制及应用场景 - 对你说早安 - 博客园https://www.cnblogs.com/lzfsuifeng/p/9590705.html

### 反射机制提供了哪些功能？

- 在运行时判定任意一个对象所属的类
- 在运行时判定任意一个类所具有的成员变量和方法；
- 在运行时构造任意一个类的对象；
- 在运行时调用任意一个对象的方法；
- 生成动态代理；

### 应用场景

Java运行时的原理？

动态代理

- 逆向代码 ，例如反编译
- 与注解相结合的框架 例如Retrofit
- 单纯的反射机制应用框架 例如EventBus 2.x
- 动态生成类框架 例如Gson

### 反射机制的优缺点：

 **优点：**

  运行期类型的判断，动态类加载，动态代理使用反射。

 **缺点：**

  性能是一个问题，反射相当于一系列解释操作，通知jvm要做的事情，性能比直接的java代码要慢很多。

[Java中的static变量、方法、代码块初始化执行顺序]: https://www.cnblogs.com/DreamDrive/archive/2011/11/15/3917139.html



Java中的静态变量和静态代码块是在类加载的时候就执行的，实例化对象时，先声明并实例化变量再执行构造函数。如果子类继承父类，则先执行父类的静态变量和静态代码块，再执行子类的静态变量和静态代码块。同样，接着在执行父类和子类非静态代码块和构造函数。

注意：（静态）变量和（静态）代码块的也是有执行顺序的，与代码书写的顺序一致。在（静态）代码块中可以使用（静态）变量，但是被使用的（静态）变量必须在（静态）代码块前面声明。

 最后给出执行步骤：

**1、父类静态变量和静态代码块（先声明的先执行）；**

**2、子类静态变量和静态代码块（先声明的先执行）；**

**3、父类的变量和代码块（先声明的先执行）；**

**4、父类的构造函数；**

**5、子类的变量和代码块（先声明的先执行）；**

**6、子类的构造函数。**